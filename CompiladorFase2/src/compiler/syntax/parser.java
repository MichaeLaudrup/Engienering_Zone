
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jun 15 22:26:06 CEST 2020
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import java.util.ArrayList;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Jun 15 22:26:06 CEST 2020
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\162\000\002\002\004\000\002\056\002\000\002\002" +
    "\004\000\002\057\002\000\002\003\005\000\002\003\004" +
    "\000\002\004\005\000\002\004\004\000\002\005\013\000" +
    "\002\005\012\000\002\005\010\000\002\006\004\000\002" +
    "\006\002\000\002\006\004\000\002\012\004\000\002\012" +
    "\003\000\002\013\006\000\002\013\005\000\002\014\003" +
    "\000\002\014\003\000\002\007\004\000\002\007\002\000" +
    "\002\007\004\000\002\015\004\000\002\015\003\000\002" +
    "\016\015\000\002\016\005\000\002\010\004\000\002\010" +
    "\002\000\002\010\004\000\002\017\004\000\002\017\003" +
    "\000\002\020\006\000\002\020\005\000\002\021\005\000" +
    "\002\021\003\000\002\022\003\000\002\022\003\000\002" +
    "\060\002\000\002\011\006\000\002\011\002\000\002\061" +
    "\002\000\002\023\010\000\002\023\005\000\002\023\004" +
    "\000\002\025\005\000\002\025\002\000\002\026\005\000" +
    "\002\026\003\000\002\026\002\000\002\027\005\000\002" +
    "\027\005\000\002\024\004\000\002\024\002\000\002\024" +
    "\005\000\002\033\003\000\002\033\003\000\002\033\005" +
    "\000\002\033\003\000\002\034\005\000\002\034\005\000" +
    "\002\034\003\000\002\035\005\000\002\035\005\000\002" +
    "\035\005\000\002\035\004\000\002\035\003\000\002\030" +
    "\004\000\002\030\003\000\002\030\002\000\002\031\005" +
    "\000\002\031\003\000\002\032\003\000\002\032\003\000" +
    "\002\032\003\000\002\032\003\000\002\032\003\000\002" +
    "\032\003\000\002\032\003\000\002\032\003\000\002\043" +
    "\004\000\002\043\005\000\002\042\005\000\002\042\005" +
    "\000\002\044\010\000\002\044\005\000\002\044\005\000" +
    "\002\045\004\000\002\045\002\000\002\046\013\000\002" +
    "\046\012\000\002\046\005\000\002\037\003\000\002\037" +
    "\004\000\002\040\005\000\002\040\004\000\002\040\004" +
    "\000\002\041\005\000\002\041\003\000\002\047\006\000" +
    "\002\047\005\000\002\050\006\000\002\050\005\000\002" +
    "\051\003\000\002\036\003\000\002\036\004\000\002\036" +
    "\004\000\002\052\005\000\002\053\003\000\002\053\003" +
    "\000\002\054\003\000\002\054\003\000\002\055\003\000" +
    "\002\055\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\306\000\004\012\000\001\002\000\004\002\310\001" +
    "\002\000\004\012\007\001\002\000\004\002\uffff\001\002" +
    "\000\006\003\305\004\306\001\002\000\016\003\012\013" +
    "\ufffe\015\ufffe\021\ufffe\022\ufffe\023\ufffe\001\002\000\014" +
    "\013\ufff5\015\ufff5\021\013\022\ufff5\023\ufff5\001\002\000" +
    "\004\002\ufffc\001\002\000\006\003\272\004\273\001\002" +
    "\000\004\002\ufffd\001\002\000\012\013\uffec\015\uffec\022" +
    "\017\023\uffec\001\002\000\010\013\uffe5\015\uffe5\023\045" +
    "\001\002\000\006\003\020\004\021\001\002\000\010\013" +
    "\uffeb\015\uffeb\023\uffeb\001\002\000\006\003\025\045\026" +
    "\001\002\000\012\004\uffe9\013\uffe9\015\uffe9\023\uffe9\001" +
    "\002\000\012\004\021\013\uffed\015\uffed\023\uffed\001\002" +
    "\000\012\004\uffea\013\uffea\015\uffea\023\uffea\001\002\000" +
    "\004\043\044\001\002\000\004\010\027\001\002\000\004" +
    "\037\030\001\002\000\006\004\031\052\033\001\002\000" +
    "\006\040\uff92\041\uff92\001\002\000\004\041\034\001\002" +
    "\000\006\040\uff93\041\uff93\001\002\000\006\004\031\052" +
    "\033\001\002\000\004\040\036\001\002\000\004\011\037" +
    "\001\002\000\006\005\040\006\042\001\002\000\006\036" +
    "\uff95\043\uff95\001\002\000\004\043\043\001\002\000\006" +
    "\036\uff94\043\uff94\001\002\000\012\004\uffe8\013\uffe8\015" +
    "\uffe8\023\uffe8\001\002\000\012\004\uffe7\013\uffe7\015\uffe7" +
    "\023\uffe7\001\002\000\006\003\260\004\243\001\002\000" +
    "\006\013\uffd9\015\047\001\002\000\006\003\224\004\225" +
    "\001\002\000\014\013\ufff5\015\ufff5\021\013\022\ufff5\023" +
    "\ufff5\001\002\000\004\013\052\001\002\000\024\003\072" +
    "\004\074\014\uffbc\016\060\024\064\030\076\032\053\033" +
    "\071\034\056\001\002\000\006\003\215\035\214\001\002" +
    "\000\010\014\uffb5\025\uffb5\043\uffb5\001\002\000\004\014" +
    "\210\001\002\000\010\014\uff9a\025\uff9a\043\uff9a\001\002" +
    "\000\010\014\uffb2\025\uffb2\043\uffb2\001\002\000\020\003" +
    "\206\004\113\020\111\035\106\052\102\053\103\054\104" +
    "\001\002\000\010\014\uffb3\025\uffb3\043\uffb3\001\002\000" +
    "\006\003\201\051\202\001\002\000\010\014\uffbd\025\uffbd" +
    "\043\177\001\002\000\020\003\166\004\113\020\111\035" +
    "\106\052\102\053\103\054\104\001\002\000\010\014\uffb9" +
    "\025\uffb9\043\uffb9\001\002\000\010\014\uffba\025\uffba\043" +
    "\uffba\001\002\000\010\014\uffb8\025\uffb8\043\uffb8\001\002" +
    "\000\010\014\uffb7\025\uffb7\043\uffb7\001\002\000\006\003" +
    "\160\035\161\001\002\000\010\002\ufff7\013\ufff7\015\ufff7" +
    "\001\002\000\010\014\uffb4\025\uffb4\043\uffb4\001\002\000" +
    "\020\003\uff99\014\uffa5\025\uffa5\035\116\037\115\043\uffa5" +
    "\051\uff99\001\002\000\010\014\uffb6\025\uffb6\043\uffb6\001" +
    "\002\000\006\003\077\004\100\001\002\000\004\043\156" +
    "\001\002\000\004\051\101\001\002\000\016\004\113\020" +
    "\111\035\106\052\102\053\103\054\104\001\002\000\040" +
    "\003\uffc4\014\uffc4\017\uffc4\025\uffc4\026\uffc4\027\uffc4\031" +
    "\uffc4\036\uffc4\040\uffc4\042\uffc4\043\uffc4\045\uffc4\046\uffc4" +
    "\047\uffc4\050\uffc4\001\002\000\040\003\uff91\014\uff91\017" +
    "\uff91\025\uff91\026\uff91\027\uff91\031\uff91\036\uff91\040\uff91" +
    "\042\uff91\043\uff91\045\uff91\046\uff91\047\uff91\050\uff91\001" +
    "\002\000\040\003\uff90\014\uff90\017\uff90\025\uff90\026\uff90" +
    "\027\uff90\031\uff90\036\uff90\040\uff90\042\uff90\043\uff90\045" +
    "\uff90\046\uff90\047\uff90\050\uff90\001\002\000\016\017\134" +
    "\031\147\045\130\046\131\047\133\050\132\001\002\000" +
    "\016\004\113\020\111\035\106\052\102\053\103\054\104" +
    "\001\002\000\040\003\uffbf\014\uffbf\017\uffbf\025\uffbf\026" +
    "\uffbf\027\uffbf\031\uffbf\036\uffbf\040\uffbf\042\uffbf\043\uffbf" +
    "\045\uffbf\046\uffbf\047\uffbf\050\uffbf\001\002\000\040\003" +
    "\uffca\014\uffca\017\uffca\025\uffca\026\uffca\027\uffca\031\uffca" +
    "\036\uffca\040\uffca\042\uffca\043\uffca\045\uffca\046\uffca\047" +
    "\uffca\050\uffca\001\002\000\016\004\113\020\111\035\106" +
    "\052\102\053\103\054\104\001\002\000\040\003\uffc7\014" +
    "\uffc7\017\uffc7\025\uffc7\026\uffc7\027\uffc7\031\uffc7\036\uffc7" +
    "\040\uffc7\042\uffc7\043\uffc7\045\uffc7\046\uffc7\047\uffc7\050" +
    "\uffc7\001\002\000\044\003\uff99\014\uff99\017\uff99\025\uff99" +
    "\026\uff99\027\uff99\031\uff99\035\116\036\uff99\037\115\040" +
    "\uff99\042\uff99\043\uff99\045\uff99\046\uff99\047\uff99\050\uff99" +
    "\001\002\000\040\003\uffc9\014\uffc9\017\uffc9\025\uffc9\026" +
    "\uffc9\027\uffc9\031\uffc9\036\uffc9\040\uffc9\042\uffc9\043\uffc9" +
    "\045\uffc9\046\uffc9\047\uffc9\050\uffc9\001\002\000\016\004" +
    "\113\020\111\035\106\052\102\053\103\054\104\001\002" +
    "\000\022\003\122\004\113\020\111\035\106\036\124\052" +
    "\102\053\103\054\104\001\002\000\042\003\uff98\014\uff98" +
    "\017\uff98\025\uff98\026\uff98\027\uff98\031\uff98\036\uff98\040" +
    "\uff98\042\uff98\043\uff98\045\uff98\046\uff98\047\uff98\050\uff98" +
    "\051\uff98\001\002\000\040\003\uff97\014\uff97\017\uff97\025" +
    "\uff97\026\uff97\027\uff97\031\uff97\036\uff97\040\uff97\042\uff97" +
    "\043\uff97\045\uff97\046\uff97\047\uff97\050\uff97\001\002\000" +
    "\020\017\134\036\uff9f\042\uff9f\045\130\046\131\047\133" +
    "\050\132\001\002\000\042\003\uffa1\014\uffa1\017\uffa1\025" +
    "\uffa1\026\uffa1\027\uffa1\031\uffa1\036\uffa1\040\uffa1\042\uffa1" +
    "\043\uffa1\045\uffa1\046\uffa1\047\uffa1\050\uffa1\051\uffa1\001" +
    "\002\000\006\036\126\042\125\001\002\000\042\003\uffa2" +
    "\014\uffa2\017\uffa2\025\uffa2\026\uffa2\027\uffa2\031\uffa2\036" +
    "\uffa2\040\uffa2\042\uffa2\043\uffa2\045\uffa2\046\uffa2\047\uffa2" +
    "\050\uffa2\051\uffa2\001\002\000\016\004\113\020\111\035" +
    "\106\052\102\053\103\054\104\001\002\000\042\003\uffa3" +
    "\014\uffa3\017\uffa3\025\uffa3\026\uffa3\027\uffa3\031\uffa3\036" +
    "\uffa3\040\uffa3\042\uffa3\043\uffa3\045\uffa3\046\uffa3\047\uffa3" +
    "\050\uffa3\051\uffa3\001\002\000\020\017\134\036\uffa0\042" +
    "\uffa0\045\130\046\131\047\133\050\132\001\002\000\016" +
    "\004\113\020\111\035\106\052\102\053\103\054\104\001" +
    "\002\000\016\004\113\020\111\035\106\052\102\053\103" +
    "\054\104\001\002\000\016\004\113\020\111\035\106\052" +
    "\102\053\103\054\104\001\002\000\016\004\113\020\111" +
    "\035\106\052\102\053\103\054\104\001\002\000\016\004" +
    "\113\020\111\035\106\052\102\053\103\054\104\001\002" +
    "\000\040\003\uffc1\014\uffc1\017\uffc1\025\uffc1\026\uffc1\027" +
    "\uffc1\031\uffc1\036\uffc1\040\uffc1\042\uffc1\043\uffc1\045\uffc1" +
    "\046\uffc1\047\133\050\uffc1\001\002\000\040\003\uffc5\014" +
    "\uffc5\017\uffc5\025\uffc5\026\uffc5\027\uffc5\031\uffc5\036\uffc5" +
    "\040\uffc5\042\uffc5\043\uffc5\045\uffc5\046\uffc5\047\uffc5\050" +
    "\uffc5\001\002\000\034\003\uffc3\014\uffc3\017\134\025\uffc3" +
    "\026\uffc3\027\uffc3\031\uffc3\036\uffc3\040\uffc3\042\uffc3\043" +
    "\uffc3\046\131\047\133\001\002\000\040\003\uffc6\014\uffc6" +
    "\017\uffc6\025\uffc6\026\uffc6\027\uffc6\031\uffc6\036\uffc6\040" +
    "\uffc6\042\uffc6\043\uffc6\045\uffc6\046\uffc6\047\133\050\uffc6" +
    "\001\002\000\034\003\uffc2\014\uffc2\017\134\025\uffc2\026" +
    "\uffc2\027\uffc2\031\uffc2\036\uffc2\040\uffc2\042\uffc2\043\uffc2" +
    "\046\131\047\133\001\002\000\016\017\134\040\143\045" +
    "\130\046\131\047\133\050\132\001\002\000\042\003\uff96" +
    "\014\uff96\017\uff96\025\uff96\026\uff96\027\uff96\031\uff96\036" +
    "\uff96\040\uff96\042\uff96\043\uff96\045\uff96\046\uff96\047\uff96" +
    "\050\uff96\051\uff96\001\002\000\040\003\uffc0\014\uffc0\017" +
    "\uffc0\025\uffc0\026\uffc0\027\uffc0\031\uffc0\036\uffc0\040\uffc0" +
    "\042\uffc0\043\uffc0\045\uffc0\046\uffc0\047\uffc0\050\uffc0\001" +
    "\002\000\016\017\134\036\146\045\130\046\131\047\133" +
    "\050\132\001\002\000\040\003\uffc8\014\uffc8\017\uffc8\025" +
    "\uffc8\026\uffc8\027\uffc8\031\uffc8\036\uffc8\040\uffc8\042\uffc8" +
    "\043\uffc8\045\uffc8\046\uffc8\047\uffc8\050\uffc8\001\002\000" +
    "\016\004\113\020\111\035\106\052\102\053\103\054\104" +
    "\001\002\000\020\003\152\017\134\027\151\045\130\046" +
    "\131\047\133\050\132\001\002\000\022\004\074\014\uffbc" +
    "\016\060\024\064\030\076\032\053\033\071\034\056\001" +
    "\002\000\004\043\153\001\002\000\010\014\uffa7\025\uffa7" +
    "\043\uffa7\001\002\000\004\014\155\001\002\000\010\014" +
    "\uffa8\025\uffa8\043\uffa8\001\002\000\010\014\uffa6\025\uffa6" +
    "\043\uffa6\001\002\000\014\003\uff97\014\uffa4\025\uffa4\043" +
    "\uffa4\051\uff97\001\002\000\004\043\164\001\002\000\016" +
    "\004\113\020\111\035\106\052\102\053\103\054\104\001" +
    "\002\000\016\017\134\036\163\045\130\046\131\047\133" +
    "\050\132\001\002\000\010\014\uff9c\025\uff9c\043\uff9c\001" +
    "\002\000\010\014\uff9b\025\uff9b\043\uff9b\001\002\000\020" +
    "\003\170\017\134\026\171\045\130\046\131\047\133\050" +
    "\132\001\002\000\004\043\167\001\002\000\010\014\uffab" +
    "\025\uffab\043\uffab\001\002\000\010\014\uffac\025\uffac\043" +
    "\uffac\001\002\000\024\004\074\014\uffbc\016\060\024\064" +
    "\025\uffbc\030\076\032\053\033\071\034\056\001\002\000" +
    "\006\014\uffa9\025\174\001\002\000\004\014\176\001\002" +
    "\000\022\004\074\014\uffbc\016\060\024\064\030\076\032" +
    "\053\033\071\034\056\001\002\000\004\014\uffaa\001\002" +
    "\000\010\014\uffad\025\uffad\043\uffad\001\002\000\024\004" +
    "\074\014\uffbe\016\060\024\064\025\uffbe\030\076\032\053" +
    "\033\071\034\056\001\002\000\010\014\uffbb\025\uffbb\043" +
    "\uffbb\001\002\000\004\043\204\001\002\000\016\004\113" +
    "\020\111\035\106\052\102\053\103\054\104\001\002\000" +
    "\022\014\uffaf\017\134\025\uffaf\043\uffaf\045\130\046\131" +
    "\047\133\050\132\001\002\000\010\014\uffae\025\uffae\043" +
    "\uffae\001\002\000\022\014\uffb1\017\134\025\uffb1\043\uffb1" +
    "\045\130\046\131\047\133\050\132\001\002\000\004\043" +
    "\207\001\002\000\010\014\uffb0\025\uffb0\043\uffb0\001\002" +
    "\000\006\003\211\004\212\001\002\000\010\002\ufff8\013" +
    "\ufff8\015\ufff8\001\002\000\004\043\213\001\002\000\010" +
    "\002\ufff9\013\ufff9\015\ufff9\001\002\000\004\007\217\001" +
    "\002\000\004\043\216\001\002\000\010\014\uff9d\025\uff9d" +
    "\043\uff9d\001\002\000\004\036\220\001\002\000\010\014" +
    "\uff9e\025\uff9e\043\uff9e\001\002\000\006\013\uffdb\015\uffdb" +
    "\001\002\000\006\013\uffd9\015\047\001\002\000\004\013" +
    "\uffda\001\002\000\014\013\uffd5\015\uffd5\021\uffd5\022\uffd5" +
    "\023\uffd5\001\002\000\012\003\227\035\uffd8\043\uffd8\044" +
    "\uffd8\001\002\000\010\035\230\043\uffd3\044\uffd3\001\002" +
    "\000\014\013\uffd6\015\uffd6\021\uffd6\022\uffd6\023\uffd6\001" +
    "\002\000\006\004\243\036\uffd0\001\002\000\006\043\uffcc" +
    "\044\233\001\002\000\004\043\237\001\002\000\010\003" +
    "\234\005\040\006\042\001\002\000\004\043\236\001\002" +
    "\000\004\043\uffcd\001\002\000\004\043\uffcb\001\002\000" +
    "\014\013\uffd7\015\uffd7\021\uffd7\022\uffd7\023\uffd7\001\002" +
    "\000\006\003\251\044\252\001\002\000\006\036\uffd1\043" +
    "\247\001\002\000\004\036\246\001\002\000\010\003\uffde" +
    "\042\244\044\uffde\001\002\000\004\004\243\001\002\000" +
    "\006\003\uffdf\044\uffdf\001\002\000\006\043\uffd4\044\uffd4" +
    "\001\002\000\006\004\243\036\uffd0\001\002\000\004\036" +
    "\uffd2\001\002\000\004\043\256\001\002\000\010\004\255" +
    "\005\040\006\042\001\002\000\006\036\uffcf\043\uffcf\001" +
    "\002\000\006\036\uffdd\043\uffdd\001\002\000\006\036\uffdc" +
    "\043\uffdc\001\002\000\006\036\uffce\043\uffce\001\002\000" +
    "\006\003\264\044\265\001\002\000\006\013\uffe4\015\uffe4" +
    "\001\002\000\010\004\243\013\uffe6\015\uffe6\001\002\000" +
    "\010\004\uffe2\013\uffe2\015\uffe2\001\002\000\010\004\uffe3" +
    "\013\uffe3\015\uffe3\001\002\000\004\043\270\001\002\000" +
    "\010\004\255\005\040\006\042\001\002\000\004\043\267" +
    "\001\002\000\010\004\uffe1\013\uffe1\015\uffe1\001\002\000" +
    "\010\004\uffe0\013\uffe0\015\uffe0\001\002\000\014\004\ufff2" +
    "\013\ufff2\015\ufff2\022\ufff2\023\ufff2\001\002\000\012\013" +
    "\ufff4\015\ufff4\022\ufff4\023\ufff4\001\002\000\006\003\276" +
    "\045\277\001\002\000\014\004\273\013\ufff6\015\ufff6\022" +
    "\ufff6\023\ufff6\001\002\000\014\004\ufff3\013\ufff3\015\ufff3" +
    "\022\ufff3\023\ufff3\001\002\000\004\043\304\001\002\000" +
    "\010\052\301\053\103\054\104\001\002\000\004\043\303" +
    "\001\002\000\004\043\uffef\001\002\000\004\043\uffee\001" +
    "\002\000\014\004\ufff1\013\ufff1\015\ufff1\022\ufff1\023\ufff1" +
    "\001\002\000\014\004\ufff0\013\ufff0\015\ufff0\022\ufff0\023" +
    "\ufff0\001\002\000\016\003\ufffa\013\ufffa\015\ufffa\021\ufffa" +
    "\022\ufffa\023\ufffa\001\002\000\004\043\307\001\002\000" +
    "\016\003\ufffb\013\ufffb\015\ufffb\021\ufffb\022\ufffb\023\ufffb" +
    "\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\306\000\006\002\003\056\004\001\001\000\002\001" +
    "\001\000\006\003\005\004\007\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\057\010\001\001\000\006\005" +
    "\013\006\014\001\001\000\002\001\001\000\006\012\273" +
    "\013\270\001\001\000\002\001\001\000\004\007\015\001" +
    "\001\000\004\010\045\001\001\000\006\015\022\016\021" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\016\023\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\054" +
    "\031\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\054\034\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\053\040\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\017\260\020\261\021\256\001\001" +
    "\000\006\011\050\023\047\001\001\000\002\001\001\000" +
    "\006\005\220\006\014\001\001\000\002\001\001\000\032" +
    "\030\054\031\062\032\065\036\061\037\056\042\064\043" +
    "\074\044\066\046\067\047\053\050\072\051\060\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\033\204\034\107" +
    "\035\113\036\111\055\106\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\033\164\034\107" +
    "\035\113\036\111\055\106\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\040" +
    "\156\052\116\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\033\104\034" +
    "\107\035\113\036\111\055\106\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\033\144\034\107\035\113\036\111\055\106\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\033\143\034" +
    "\107\035\113\036\111\055\106\001\001\000\002\001\001" +
    "\000\006\040\117\052\116\001\001\000\002\001\001\000" +
    "\014\033\141\034\107\035\113\036\111\055\106\001\001" +
    "\000\016\033\120\034\107\035\113\036\111\041\122\055" +
    "\106\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\033\126\034\107\035\113\036\111\055\106" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\033" +
    "\140\034\107\035\113\036\111\055\106\001\001\000\014" +
    "\033\137\034\107\035\113\036\111\055\106\001\001\000" +
    "\014\033\136\034\107\035\113\036\111\055\106\001\001" +
    "\000\014\033\135\034\107\035\113\036\111\055\106\001" +
    "\001\000\014\033\134\034\107\035\113\036\111\055\106" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\014\033\147\034\107\035\113\036\111" +
    "\055\106\001\001\000\002\001\001\000\032\030\153\031" +
    "\062\032\065\036\061\037\056\042\064\043\074\044\066" +
    "\046\067\047\053\050\072\051\060\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\014\033\161\034\107\035\113\036\111\055\106\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\032\030\171\031\062\032\065\036\061\037" +
    "\056\042\064\043\074\044\066\046\067\047\053\050\072" +
    "\051\060\001\001\000\004\045\172\001\001\000\002\001" +
    "\001\000\032\030\174\031\062\032\065\036\061\037\056" +
    "\042\064\043\074\044\066\046\067\047\053\050\072\051" +
    "\060\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\032\177\036\061\037\056\042\064\043\074\044\066\046" +
    "\067\047\053\050\072\051\060\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\033\202\034\107\035\113\036" +
    "\111\055\106\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\060\221" +
    "\001\001\000\006\011\222\023\047\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\061\225\001\001\000\004" +
    "\025\230\001\001\000\002\001\001\000\010\021\237\026" +
    "\241\027\240\001\001\000\004\024\231\001\001\000\002" +
    "\001\001\000\004\053\234\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\021\244\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\021\237\026\247\027\240\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\022\252\053\253" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\020\262\021\256\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\022\265\053\253" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\013\274\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\014\277\055\301\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	ArrayList<QuadrupleIF> listaStrings = new ArrayList<QuadrupleIF>(); 
	/*
	 * El objetivo de este metodo es centralizar la impresion de los errores, y asi tener las acciones de la semantica mucho mas limpia y legible
	 * la relacion entre el identificador numerico de error y el texto informativo de error se recoge en un tabla en el apendice de la memoria de 
	 * la practica. 
	 *@param identificador unico, indicativo del tipo de mensaje de error que se debe imprimir.
	 *@param numero indicativo de la linea en la que se produce el error.
	 */ 
	public void manejarError(int identificador_error, int linea_error){
		String texto_informativo = "Error en la linea " + linea_error + ": "; 
		switch(identificador_error){
			case 1: 
				texto_informativo += "El simbolo referenciado no ha sido declarado previamente."; 
				break; 
			case 2: 
				texto_informativo += "Incompatibilidad entre parametros de la llamada y parametros formales de la funcion. Revise que esta todo en orden.";
				break;
			case 3:
				texto_informativo += "El identificador del final de programa o subprograma no coincide con el identificador de la cabecera del programa o subprograma."; 
				break; 
			case 4:
				texto_informativo += "El identificador del tipo que esta usted declarando ya ha sido usado para definir otros elementos (los nombres de tipos compuestos no pueden volver a utilizarse en ningun ambito)";
				break;  
			case 5:
				texto_informativo += "La referencia del lado izquierdo de una sentencia de asignacion solo puede ser una variable de tipo simple no constante o una posicion a un vector. "; 
				break; 
			case 6: 
				texto_informativo += "Se ha hecho referencia a una posicion de un vector con una expresion que da como resultado un valor logico."; 
				break; 
			case 7:
				texto_informativo += "Se esta haciendo referencia a una posicion de un vector, con una constante o un valor numerico que excede los limites de este vector"; 
				break;
			case 8: 
				texto_informativo += "Se esta utilizando es una expresion una llamada a un procedimiento.";  
				break; 
			case 9: 
				texto_informativo += "Esta haciendo referencia a un simbolo que no consiste en un proceso"; 
				break;
			case 10: 
				texto_informativo += "Se esta llamando a un parametros sin especificar parametros actuales, cuando el proceso contiene parametros formales"; 
				break; 
			case 11: 
				texto_informativo += "Se estan declarando dos o mas variables con mismo nombre en la cabecera de un procedimiento o funcion ."; 
				break; 
			case 12: 
				texto_informativo += "Los procedimientos y funciones tienen paso por valor en este caso, solo se permite el paso de parametros de tipo simple (logico o entero)";
				break; 
			case 13:
				texto_informativo += "El identificador especificado ya esta siendo usado en otro simbolo en el mismo ambito";
				break; 
			case 14: 
				texto_informativo += "No existe sentencia return en todos los puntos de salida de la funcion, revise."; 
				break; 
			case 15:
				texto_informativo += "Se debe usar una expresion logica en la parte condicional de un IF"; 
				
			case 16:
				texto_informativo += "El identificador que delimita el limite del vector no es una constante sino otro tipo de simbolo";
				break; 
			case 17:
				texto_informativo += "Se esta haciendo referencia a una constante cuyo valor no es numerico para delimitar una cota de un vector"; 
				break;
			case 18: 
				texto_informativo += "En la declaracion de un tipo vector el limite inferior no puede ser mayor que el limite superior"; 
				break;  
			case 19: 
				texto_informativo += "Tanto en el lado izquierdo como el derecho de un simbolo MAYOR, debe haber expresiones arimeticas";
				break; 
			case 20: 
				texto_informativo += "Una funcion no puede retornar un dato complejo de tipo vector.";
				break; 
			case 21: 
				texto_informativo += "Dentro de una funcion hay varios retornos que no coinciden en el tipo de dato que devuelven. "; 
				break;  
			case 22: 
				texto_informativo += "Inconcordancia de tipo de datos, entre el retorno formal de la funcion y el retorno aplicado en la seccion BEGIN-END de la funcion"; 
				break; 
			case 23:
				texto_informativo += "El iterador dentro del bucle for debe ser de tipo entero. ";
				break; 
			case 24:
				texto_informativo += "La expresion de inicio o de fin de la cabecera del bucle for no es de tipo entero"; 
				break; 
			case 25: 
				texto_informativo += "En la sentencia WRITEINT solo se pueden enviar como parametros numeros enteros. "; 
				break; 
			case 26: 
				texto_informativo += "Incompatibilidad de tipos en la expresion logica o aritmetica"; 
				break; 
			case 27: 
				texto_informativo += "Incompatibilidad de tipos en una sentencia de asignacion.";
				break;
			case 28: 
				texto_informativo += "En la asignacion dentro de una sentencia for se debe utilizar una variable simple, es decir, no se pueden usar constantes o vectores en el lado derecho de la asignacion"; 
				break; 
			case 29: 
				texto_informativo += "Tipo de dato no declarado previamente";
				break; 
			case 30: 
				texto_informativo +=": El nombre de la referencia especificado no hace alusion a un tipo vector sino a otro tipo de dato."; 
			default:
		}
	    //SE FINALINA EL ANALISIS SEMANTICO INFORMANDO AL USUARIO DEL ERROR COMETIDO
		semanticErrorManager.semanticFatalError(texto_informativo);
	}
	
	/*
	 * Este metodo comprueba si un simbolo existe en la pila de ambitos abiertos y ademas devuelve si el simbolo es una instancia de un tipo determinado.
	 * por el usuario a traves de los parametros actuales al invocar esta funcion
	 * @param String: identificador del simbolo sujeto de estudio
	 * @param String: identificador del tipo simbolo que sea desea comprobar si es instancia (SymbolFunction, SymbolProcedure...etc); 
	 * @param int : numero de linea para controlar que en caso de que se produzca error saber en que linea se esta produciendo ese error. 
	 */
	public boolean identificadorEsInstanciaDe(String identificador, String tipo_o_simbolo_a_comparar, int linea_control_error){
		if(scopeManager.containsSymbol(identificador) || scopeManager.containsType(identificador)){  //se comprueba que el simbolo o tipo existe en los ambitos abiertos
			SymbolIF simbolo_objeto_estudio =null;   //se parte de la premisa de que el simbolo es null
			TypeIF tipo_objeto_estudio =null; //se parte de la premisa de que el tipo es null
			if(tipo_o_simbolo_a_comparar.startsWith("Symbol")){   //se comprueba si la comparacion que se quiere hacer es sobre un simbolo o un tipo
				simbolo_objeto_estudio = scopeManager.searchSymbol(identificador); //en caso de ser un simbolo, se obtiene el simbolo referenciado
			}else{
				tipo_objeto_estudio = scopeManager.searchType(identificador); //en caso de ser un tipo, se obtiene el tipo referenciado
			}
			switch(tipo_o_simbolo_a_comparar){
				case "SymbolFunction": 
					return (simbolo_objeto_estudio instanceof SymbolFunction); 
				case "SymbolProcedure": 
					return (simbolo_objeto_estudio instanceof SymbolProcedure); 
				case "SymbolConstant":
					return (simbolo_objeto_estudio instanceof SymbolConstant); 
				case "SymbolVariable":
					return (simbolo_objeto_estudio instanceof SymbolVariable); 
				case "TypeSymple": 
					return (tipo_objeto_estudio instanceof TypeSimple); 
				default:
					return false; 
			}
		}else{
			manejarError(1, linea_control_error); 
			return false; 
		}
	}
	/* La funcion de este metodo es comprobar si dos ArrayList, los cuales, contienen parametros formales y actuales de una funcion
	 * son iguales.
	 *@param listado de parametros en la llamada de la funcion
	 *@param listado de parametros formales de la funcion
	 */
	public boolean parametrosActuales_igual_parametrosFormales(ArrayList<String> parametros_actuales, ArrayList<String> parametros_formales){
    	if((parametros_actuales.toString()).equalsIgnoreCase(parametros_formales.toString())){
    		return true; 
    	}else{
    		return false;  
    	}
	}
	/* Este metodo trata el limite superior e inferior en la declaracion de un tipo ARRAY
	 * @param limite de tipo entero o identificador constante
	 * @param linea de control por si se produce un error
	 */
	public String tratarLimite(EntOid limite, int linea_control){
			if(limite.esIdentificador()){
				if(identificadorEsInstanciaDe(limite.getValor(), "SymbolConstant", linea_control)){
					SymbolConstant simbolo_cte = (SymbolConstant)scopeManager.searchSymbol(limite.getValor()); 
   					if(simbolo_cte.esCteNumerica()){
   						return simbolo_cte.getValor();
   					}else{
   						manejarError(17, linea_control);
   						return null; 
   					}
				}else{
					manejarError(16,linea_control); 
					return null; 
				}		
			}else{
				return limite.getValor(); 	
			}	
	}
	/*
	 * Con el fin de evitar duplicacion de codigo en el tratamiento de las sentencias  del cuerpo de un programa o subprograma se crea este metodo
	 *(dado que son practicamente identicas para varias producciones)
	 * @param listado de sentencias 
	 * @param linea de control por si se produce error
	 */
	public Sentencias manejarSentencias(ListSentencia listado_sentencias, int linea_control_error){
	  	 Sentencias bloque_sentencias = new Sentencias(); 
  		 if(listado_sentencias.existeSentenciaReturn()){
  			 if(listado_sentencias.todosLosRetornosSonDelMismoTipo()){
  			  	 bloque_sentencias.setTipoRetorno(listado_sentencias.obtenerTipoRetorno());
  			  	 bloque_sentencias.retornoEncontrado(); 
  			 }else{
  			  	  manejarError(21, linea_control_error); 
  			 }
  		 }
	  return bloque_sentencias; 
	}
	//*******************************
	// METODOS DE CODIGO INTERMEDIO
	//*******************************
	/*
	 * Este metodo se encarga de gestionar todas la operaciones binarias del codigo intermedio (RESTAR, MULTIPLICAR...etc).
	 *@param ambito desde el cual se ha invocado la operacion binaria
	 *@param expresion izquierda de la operacion binaria
	 *@param expresion derecha de la operancion binaria
	 *@param cadena de texto indicativa del tipo operacion binaria a realizar
	 *@param Expresion aritmetica (en caso de ser una operacion binaria aritmetica se alteran atributos de este objeto, lo cual, repercute en el objeto ExprArit recibido como parametro actual
	 *@param Expresion logica (en caso de ser una operacion logica se alteran atributos de este objeto repercutiendo en parametro actual asociado. Sera null en caso de que no sea una operacion aritmetica
	 */
	public void gestionarOperacionBinariaCI(ScopeIF ambito, Expresion expresion_izq, Expresion expresion_der, String tipoOperacion, ExprArit exp_arit, ExprLogica exp_logic ){
  		TemporalFactory factoria_temporales = new TemporalFactory(ambito); 
  	    IntermediateCodeBuilder factoria_intermedio = new IntermediateCodeBuilder(ambito); 
  	    TemporalIF temporal_expresion_izq = expresion_izq.getTemporal();
		TemporalIF temporal_expresion_der = expresion_der.getTemporal();
  	    TemporalIF temporal_resultado_op = factoria_temporales.create(); 
  	    factoria_intermedio.addQuadruples(expresion_izq.getIntermediateCode());
  	    factoria_intermedio.addQuadruples(expresion_der.getIntermediateCode()); 
  	    boolean codigoIntermedioAritmetico = false; //se parte de la premisa de que el codigo intermedio no es aritmetico
  	   	switch(tipoOperacion){
  	   		case "RESTAR":
				factoria_intermedio.addQuadruple("SUB", temporal_resultado_op, temporal_expresion_izq, temporal_expresion_der);  
				codigoIntermedioAritmetico = true; 
				break; 
			case "MULTIPLICAR": 
			    factoria_intermedio.addQuadruple("MUL", temporal_resultado_op, temporal_expresion_izq, temporal_expresion_der);
			    codigoIntermedioAritmetico = true;   
				break; 
			case "MAYOR":
			    factoria_intermedio.addQuadruple("GR", temporal_resultado_op, temporal_expresion_izq, temporal_expresion_der); 
				break;
			case "IGUAL":
			    factoria_intermedio.addQuadruple("EQ", temporal_resultado_op, temporal_expresion_izq, temporal_expresion_der);   
				break; 
			case "OR":
			    factoria_intermedio.addQuadruple("OR", temporal_resultado_op, temporal_expresion_izq, temporal_expresion_der);   
				break; 
			default: 
  	   	}     	   	
  	   	if(exp_arit != null &&  codigoIntermedioAritmetico){  //Se establece doble control (aunque no sea necesario) para garantizar seguridad
  	   		exp_arit.setIntermediateCode(factoria_intermedio.create()); 
  	   		exp_arit.setTemporal(temporal_resultado_op); 
  	   	}else if(exp_logic != null && !codigoIntermedioAritmetico){
  	   		exp_logic.setIntermediateCode(factoria_intermedio.create()); 
  	   		exp_logic.setTemporal(temporal_resultado_op);                	   		
  	   	}
  	}

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // vBooleano ::= FALSE 
            {
              VBooleano RESULT =null;
		
                	VBooleano valor_logico = new VBooleano("FALSE"); 
                	RESULT = valor_logico; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("vBooleano",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // vBooleano ::= TRUE 
            {
              VBooleano RESULT =null;
		
					VBooleano valor_logico = new VBooleano("TRUE");
					RESULT = valor_logico; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("vBooleano",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // entOid ::= IDENTIFICADOR 
            {
              EntOid RESULT =null;
		int valor_simbolicoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_simbolicoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor_simbolico = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                      EntOid identificador = new EntOid();
					  identificador.set_esIdentificador(true);
					  identificador.setValor(valor_simbolico.getLexema());
					  
                      RESULT = identificador;  
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("entOid",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // entOid ::= ENTERO 
            {
              EntOid RESULT =null;
		int valor_enteroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_enteroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token valor_entero = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					  EntOid entero = new EntOid();
					  entero.set_esIdentificador(false);
					  entero.setValor(valor_entero.getLexema());
                      RESULT = entero;  
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("entOid",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // intOBool ::= BOOLEAN 
            {
              IntOBool RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	IntOBool tipoDato= new IntOBool();
                	tipoDato.setTipo("LOGICO");
					RESULT = tipoDato; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("intOBool",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // intOBool ::= INTEGER 
            {
              IntOBool RESULT =null;
		int inteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int interight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token inte = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					IntOBool tipoDato= new IntOBool();
                	tipoDato.setTipo("ENTERO");
					RESULT = tipoDato;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("intOBool",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // idArray ::= CORCHIZQ expresion CORCHDER 
            {
              IdArray RESULT =null;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						if(exp.esLogica()){
							manejarError(6,linea.getLine()); 
						}else{
							IdArray referencia_vector = new IdArray(); 
							//** FALTA PONER AQUI QUE EN CASO DE SER UN VALOR ENTERO SIMPLE LO MISMO
							if(exp.esExpresionConstante() ){
								referencia_vector.setValor(exp.getValorExpresionConstante()); 
								
							}else if(exp.esUnNumeroSimple()){
								referencia_vector.setValor(exp.getValorNumericoSimple()); 
							}
					//******************************CODIGO INTERMEDIO************************
					    referencia_vector.setTemporal(exp.getTemporal()); 
					    referencia_vector.setIntermediateCode(exp.getIntermediateCode()); 
						RESULT = referencia_vector; 
					//**********************************************************************
						}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("idArray",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // variables ::= IDENTIFICADOR parFuncion 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int parametros_llamadaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametros_llamadaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParFuncion parametros_llamada = (ParFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        //SE CREA UN OBJETO DE TIPO **Variables** PARA GUARDAR EN EL LOS ATRIBUTOS OPORTUNOS Y PROPAGARLOS HACIA ARRIBA
                		Variables referencia_funcion = new Variables("REFERENCIA_FUNCION");
                		
                		//SE ALMACENA EN EL OBJETO DE TIPO **Variables** EL IDENTIFICADOR  AL QUE HACE REFERENCIA
                		referencia_funcion.setIdentificador(id.getLexema());
                		
                		//SE ALMACENA LA LINEA EN LA QUE SE ESTA HACIENDO REFERENCIA A LA FUNCION PARA FUTUROS CONTROLES 
                		referencia_funcion.setLineaError(id.getLine());  
                		
                		//SE COMPRUEBA SI EXISTE EL SIMBOLO EN LOS AMBITOS ACTUALMENTE ABIERTOS
                		if(scopeManager.containsSymbol(id.getLexema())){
                		
                			//EN CASO DE QUE EXISTA EL SIMBOLO SE COMPRUEBA QUE EL TIPO DE ESTE SIMBOLO SEA DE TIPO FUNCION DADO QUE EN UNA EXPRESION SE TRATA CON FUNCIONES EN ESTE CONTEXTO
                			SymbolIF nuevo_simbolo = scopeManager.searchSymbol(id.getLexema()); 
                		    if(nuevo_simbolo instanceof SymbolFunction){
                		    	//SE HACE UN CASTING DE SIMBOLO GENERICO A SIMBOLO FUNCION
                		    	SymbolFunction funcion_formal = (SymbolFunction)nuevo_simbolo; 
                		    	
                		    	//SE HACE UN CASTING PARA PODER ACCEDER A LOS METODOS PROPIOS DE LA CLASE SYMBOLFUNCTION Y SE OBTIENE EL TIPO
                		    	String tipo_retorno = funcion_formal.getTipoRetorno(); 
                		    	
                		    	//SE ALMACENA EN EL OBJETO DE TIPO **Variables** EL TIPO QUE DEVUELVE LA FUNCION PARA PROPAGARLO HACIA ARRIBA
                		    	referencia_funcion.setTipo(tipo_retorno);
                		    	
                		    	// SE COMPRUEBAN QUE TANTO LOS PARAMETROS ACTUALES COMO LOS PARAMETROS FORMALES COINCIDEN EN NUMERO Y TIPO
                		    	if(parametrosActuales_igual_parametrosFormales(parametros_llamada.getListaParametrosLlamada(), funcion_formal.getParametrosFormales())){
                		    		//SE PROPAGA HACIA ARRIBA EL OBJETO DE TIPO **VARIABLES** CON TODOS SUS ATRIBUTOS BIEN INSTANCIADOS 
                		    	    RESULT = referencia_funcion; 
                		    	}else{
                		    		manejarError(2,id.getLine()); 
                		    	}
                		    }else{
                		    	manejarError(8, id.getLine()); 
                		    }
                		}else{
                		    //SI NO SE ENCUENTRA NINGUN SIMBOLO ASOCIADO AL IDENTIFICADOR PROPORCIONADO EN LA REFERENCIA SE INFORMA DE ERROR Y SE INTERRUMPE SEMANTICO
                			manejarError(1,id.getLine()); 
                		}
                	  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // variables ::= IDENTIFICADOR idArray 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int id_arrayleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id_arrayright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IdArray id_array = (IdArray)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                		if(scopeManager.containsSymbol(id.getLexema())){ 
                			//OBTENEMOS EL NOMBRE DEL TIPO DE VECTOR AL QUE SE HACE REFERENCIA
                			SymbolIF vector_referenciado = scopeManager.searchSymbol(id.getLexema()); 
                			
                			TypeIF tipo_simbolo = vector_referenciado.getType();  
                			// SE PARTE DE LA PREMISA DE QUE SI EL SIMBOLO EXISTE, SU TIPO TAMBIEN, DADO QUE NO SE PUEDE CREAR NINGUN SIMBOLO, SIN ANTES HABER INSERTADO EL TIPO
                			//SE COMPRUEBA EL TIPO ES UNA INSTANCIA DE LA CLASE TypeArray
                			if(tipo_simbolo instanceof TypeArray){
                				Variables referencia_vector = new Variables("REFERENCIA_VECTOR");
                				referencia_vector.setIdentificador(id.getLexema());
                				TypeArray tipo_array = (TypeArray)tipo_simbolo;	
                				
                				//SE COMPRUEBA INTEGRIDAD DE LIMITES EN CASO DE SER UN NUMERO ENTERO O UNA CONSTANTE NUMERICA
                				if(id_array.tieneValorCalculableEnCompilacion()){
                					int limite_inferior = tipo_array.getLimiteInferior();
                					int limite_superior = tipo_array.getLimiteSuperior();
                					int valor_referenciado = id_array.getValor(); 
                					if(!(valor_referenciado >= limite_inferior) && !(valor_referenciado <= limite_superior)){
 										manejarError(7,id.getLine()); 
                					}
                				}//PONER ELSE SI ES NECESARIO CONTROLAR DE MANERA EXPLICITA CON CI QUE NO SE EXCEDEN LIMITES DE VECTOR   
                				//ALMACENAMOS EL TIPO PRIMITIVO DE LOS DATOS DEL VECTOR, DADO QUE ES LO QUE NOS INTERESA PARA PROPAGAR
        						referencia_vector.setTipo(tipo_array.getTipoDatoVector()); 
        						referencia_vector.setLineaError(id.getLine());
        						//***************************************CODIGO INTERMEDIO*************************************************
		                		IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
		                		fabrica_intermedio.addQuadruples(id_array.getIntermediateCode()); 
		                		TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
		                        TemporalIF temp_indiceVector = id_array.getTemporal();  
		                        TemporalIF temp_indiceVectorNormalizado = fabrica_temporales.create(); 
		                        TemporalIF temp_DireccionBaseArray = fabrica_temporales.create(); 
		                        TemporalIF temp_DesplazamientoRespectoBase = fabrica_temporales.create(); 
        					    Variable variable_referenciada = new Variable(id.getLexema(), vector_referenciado.getScope());
        					    Value index_inferior_vector = new Value(tipo_array.getLimiteInferior());  
        					    fabrica_intermedio.addQuadruple("SUB", temp_indiceVectorNormalizado,temp_indiceVector , index_inferior_vector);  
        					    fabrica_intermedio.addQuadruple("MVA", temp_DireccionBaseArray, variable_referenciada);
        					    fabrica_intermedio.addQuadruple("SUB", temp_DesplazamientoRespectoBase, temp_DireccionBaseArray, temp_indiceVectorNormalizado ); 
        					    referencia_vector.setTemporal(temp_DesplazamientoRespectoBase); 
        					    referencia_vector.setIntermediateCode(fabrica_intermedio.create()); 
        						//**********************************************************************************************************
        						RESULT = referencia_vector;         				              					
                			}else{
                				manejarError(30,id.getLine()); 
                			}
                		}else{
                			manejarError(1,id.getLine()); 
                		}	
        				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // variables ::= IDENTIFICADOR 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						
						Variables referencia_simple; 
						//SE INSTANCIA UN OBJETO DE TIPO VARIABLES Y SE HACE ALUSION A QUE ES UNA REFERENCIA SIMPLE Y SE ASIGNA SU IDENTIFICADOR ASOCIADO	
						referencia_simple = new Variables("REFERENCIA_SIMPLE"); 
						referencia_simple.setIdentificador(id.getLexema());
						
						//SE ASIGNA EL ATRIBUTO NUMERO DE LINEA AL OBJETO ANTERIORMENTE INSTANCIADO PARA PROPAGARLO HACIA ARRIBA Y CONTROLAR LINEA DE POSIBLES ERRORES
						referencia_simple.setLineaError(id.getLine()); 
 						
 						//SE COMPRUEBA QUE EXISTE EL IDENTIFICADOR REFERENCIADO, Y SE ASIGNA AL OBJETO REFERENCIA_SIMPLE EL NOMBRE DE TIPO PARA PROPAGARLO HACIA ARRIBA
 						if(scopeManager.containsSymbol(id.getLexema())){
 							SymbolIF simbolo_referenciado = scopeManager.searchSymbol(id.getLexema());
 							//HAY QUE COMPROBAR QUE EL SIMBOLO ES INSTANCIA DE **SymbolFunction** PARA QUE LA REFERENCIA NO SEA **TypeFunction** SINO EL TIPO DE RETORNO DE ESA FUNCION.
 							if(simbolo_referenciado instanceof SymbolFunction ){
 								referencia_simple.setTipoReferencia("REFERENCIA_FUNCION"); 
 								referencia_simple.setTipo(((SymbolFunction)simbolo_referenciado).getTipoRetorno()); 
 							}else{
 								referencia_simple.setTipo(simbolo_referenciado.getType().getName()); 
 							}
 							if(simbolo_referenciado instanceof SymbolConstant){
 								referencia_simple.setEsReferenciaConstante(true);
 								referencia_simple.setValorReferenciaConstante(((SymbolConstant)simbolo_referenciado).getValor()); 
 							}				
 						}else{
 							manejarError(1, id.getLine()); 
 						}					
						
						///SE PROPAGA HACIA ARRIBA EL OBJETO Y SUS ATRIBUTOS
				        RESULT = referencia_simple; 
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // sWriteLn ::= WRITELN 
            {
              SWriteLn RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteLn",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // sWriteInt ::= WRITEINT error PUNTOYCOMA 
            {
              SWriteInt RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteInt",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // sWriteInt ::= WRITEINT PARENIZQ expresion PARENDER 
            {
              SWriteInt RESULT =null;
		int impresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int impresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion impresion = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						if(!impresion.getTipoExpresion().equalsIgnoreCase("ENTERO")){
							manejarError(25, control_linea.getLine()); 
						}
						
						
					//***************CODIGO INTERMEDIO**********************
					IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
					TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
					fabrica_intermedio.addQuadruples(impresion.getIntermediateCode()); 
					fabrica_intermedio.addQuadruple("ESCRIBIR_ENTERO", impresion.getTemporal()); 
					SWriteInt escribir_entero = new SWriteInt(); 
					escribir_entero.setIntermediateCode(fabrica_intermedio.create()); 
					RESULT = escribir_entero; 
					//*****************************************************
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteInt",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // sWriteString ::= WRITESTRING error PUNTOYCOMA 
            {
              SWriteString RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteString",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // sWriteString ::= WRITESTRING PARENIZQ STRING PARENDER 
            {
              SWriteString RESULT =null;
		int textoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int textoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token texto = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					SWriteString sentencia_impresion = new SWriteString(); 
				    TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
				    IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
					String cadena_texto = texto.getLexema(); 
					LabelFactory fabricaEtiquetas = new LabelFactory();
					LabelIF etiqueta_texto = fabricaEtiquetas.create(); 
					fabrica_intermedio.addQuadruple("ESCRIBE_TEXTO",etiqueta_texto);
					listaStrings.add(new Quadruple("ETIQUETA", new Label(cadena_texto), etiqueta_texto)); 
				    sentencia_impresion.setIntermediateCode(fabrica_intermedio.create()); 
				    RESULT = sentencia_impresion; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteString",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // parametros ::= expresion 
            {
              Parametros RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	Parametros lista_param = new Parametros(); 
                	lista_param.insertarParametro(exp.getTipoExpresion()); 
                	RESULT = lista_param; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // parametros ::= parametros COMA expresion 
            {
              Parametros RESULT =null;
		int lista_parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lista_parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Parametros lista_parametros = (Parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expresion = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    lista_parametros.insertarParametro(expresion.getTipoExpresion()); 
                    RESULT = lista_parametros; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // parFuncion ::= PARENIZQ error 
            {
              ParFuncion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // parFuncion ::= PARENIZQ PARENDER 
            {
              ParFuncion RESULT =null;
		
                	//SE INVOCA UN CONSTRUCTOR EN EL QUE NO SE ENVIA NINGUNA LISTA COMO PARAMETRO, ESTE CONSTRUCTOR INDICARA QUE NO HAY PARAMETROS EN LA LLAMADA
                	ParFuncion llamada = new ParFuncion(); 
                	RESULT = llamada; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // parFuncion ::= PARENIZQ parametros PARENDER 
            {
              ParFuncion RESULT =null;
		int lista_parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lista_parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Parametros lista_parametros = (Parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					//SE PROPAGA LA LISTA DE PARAMETROS REFERENCIADOS EN UNA LLAMADA A UNA FUNCION O A UN PROCEDIMIENTO HACIA ARRIBA DADO QUE EN ESTE PUNTO
					//NO SE PUEDE CONTROLAR SI HAY COHERENCIA CON LOS PARAMETROS FORMALES DE LA FUNCION
					ParFuncion llamada = new ParFuncion(lista_parametros.getListaParametros());
					RESULT = llamada; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // sentProcedure ::= IDENTIFICADOR parFuncion 
            {
              SentProcedure RESULT =null;
		int id_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id_proceso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParFuncion parametros = (ParFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	if(identificadorEsInstanciaDe(id_proceso.getLexema(), "SymbolProcedure", id_proceso.getLine())){
                		SymbolProcedure  simbolo_proceso  = (SymbolProcedure)scopeManager.searchSymbol(id_proceso.getLexema()); 
						if(parametros.existenParametrosLlamada()){
							if(!(parametrosActuales_igual_parametrosFormales(parametros.getListaParametrosLlamada(), simbolo_proceso.getParametrosFormales()))){
								manejarError(2,id_proceso.getLine()); 
							}
						}else{
							if(simbolo_proceso.getNumParametrosFormales() != 0){
						 		manejarError(10,id_proceso.getLine()); 
					   		}
						}
					}else{
						manejarError(9,id_proceso.getLine()); 
					}
                
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentProcedure",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // sentProcedure ::= IDENTIFICADOR 
            {
              SentProcedure RESULT =null;
		int id_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id_proceso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					if(identificadorEsInstanciaDe(id_proceso.getLexema(), "SymbolProcedure", id_proceso.getLine())){
					    SymbolProcedure  simbolo_proceso  = (SymbolProcedure)scopeManager.searchSymbol(id_proceso.getLexema()); 
					    if(simbolo_proceso.getNumParametrosFormales() != 0){
						 	manejarError(10,id_proceso.getLine()); 
					    }
					}else{
						manejarError(9,id_proceso.getLine()); 
					}

				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentProcedure",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentFor ::= FOR error PUNTOYCOMA 
            {
              SentFor RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentFor ::= FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion error PUNTOYCOMA 
            {
              SentFor RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentFor ::= FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion DO sentencias END 
            {
              SentFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int inicioleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int inicioright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expresion inicio = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int finleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int finright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expresion fin = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sentencias_bucleleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencias_bucleright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencias sentencias_bucle = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(identificadorEsInstanciaDe(id.getLexema(), "SymbolVariable", control_linea.getLine())){
   							if(scopeManager.searchSymbol(id.getLexema()).getType().getName().equalsIgnoreCase("ENTERO")){
   								if((inicio.getTipoExpresion().equalsIgnoreCase("ENTERO")) || (fin.getTipoExpresion().equalsIgnoreCase("ENTERO"))){
   									//********************** CODIGO INTERMEDIO ******************************
   									IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
				   					TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
				   					LabelFactory fabrica_etiquetas = new LabelFactory(); 
				   					Variable indice_for = new Variable(id.getLexema(), scopeManager.searchSymbol(id.getLexema()).getScope()); 
   									fabrica_intermedio.addQuadruples(inicio.getIntermediateCode()); 
  									fabrica_intermedio.addQuadruples(fin.getIntermediateCode());
  								
   									TemporalIF temp_asignacion_inicial = inicio.getTemporal(); 
   									TemporalIF temp_limiteSuperior_for = fin.getTemporal();
   									TemporalIF temp_limiteSuperior_forPLUS1 = fabrica_temporales.create(); //EL LIMITE SUPERIOR DEBE ESTAR UNA UNIDAD INCREMENTADO PARA INCLUIR EL LIMITE SUPERIOR ORIGINAL EN LAS VUELTAS DEL FOR
   									fabrica_intermedio.addQuadruple("ADD", temp_limiteSuperior_forPLUS1, temp_limiteSuperior_for, new Value(1)  ); 
   									TemporalIF temp_direccionIndice_for = fabrica_temporales.create(); 
   									TemporalIF temp_resultadoComparacionPorVuelta = fabrica_temporales.create(); 
   									fabrica_intermedio.addQuadruple("MVA", temp_direccionIndice_for, indice_for); 
									fabrica_intermedio.addQuadruple("STP", temp_direccionIndice_for, temp_asignacion_inicial); 
									LabelIF inicioFor = fabrica_etiquetas.create(); 
									LabelIF finFor = fabrica_etiquetas.create();
									TemporalIF valor_actual_indiceFor = fabrica_temporales.create();  
									fabrica_intermedio.addQuadruple("INL", inicioFor); 
									fabrica_intermedio.addQuadruple("MVP", valor_actual_indiceFor, temp_direccionIndice_for); 
									fabrica_intermedio.addQuadruple("EQ", temp_resultadoComparacionPorVuelta, valor_actual_indiceFor ,temp_limiteSuperior_forPLUS1); 
									fabrica_intermedio.addQuadruple("BRT", temp_resultadoComparacionPorVuelta, finFor );
   									fabrica_intermedio.addQuadruples(sentencias_bucle.getIntermediateCode()); 
   									Value incrementoPorVuelta = new Value(1); 
									TemporalIF resultado_suma = fabrica_temporales.create();
   									fabrica_intermedio.addQuadruple("ADD", resultado_suma ,valor_actual_indiceFor, incrementoPorVuelta); 
   									fabrica_intermedio.addQuadruple("STP",  temp_direccionIndice_for, resultado_suma);
   									fabrica_intermedio.addQuadruple("BR", inicioFor); 
   									fabrica_intermedio.addQuadruple("INLFIN", finFor); 
   									SentFor sentencia_for = new SentFor(); 
   									sentencia_for.setIntermediateCode(fabrica_intermedio.create()); 
   									RESULT = sentencia_for; 
									//***********************************************************************
   								}else{
   									manejarError(24,control_linea.getLine()); 
   								}
   							}else{
   								manejarError(23,control_linea.getLine()); 
   							}  							
   						}else{
   							manejarError(26,control_linea.getLine()); 
   						} 					
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentElse ::= 
            {
              SentElse RESULT =null;
		
                	SentElse sentencia_else = new SentElse(); 
                	sentencia_else.marcarComoVacia(); 
                	RESULT = sentencia_else; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentElse ::= ELSE sentencias 
            {
              SentElse RESULT =null;
		int instruccionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int instruccionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias instrucciones = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	SentElse sentencia_else = new SentElse(); 
                	if(instrucciones.existeSentenciaReturn()){
                		sentencia_else.retornoEncontrado(); 
                	}
                	sentencia_else.setIntermediateCode(instrucciones.getIntermediateCode()); 
                	RESULT = sentencia_else; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentIf ::= IF error PUNTOYCOMA 
            {
              SentIf RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentIf ::= IF expresion error 
            {
              SentIf RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentIf ::= IF expresion THEN sentencias sentElse END 
            {
              SentIf RESULT =null;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int condicionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int condicionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion condicion = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sentencias_ifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentencias_ifright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencias sentencias_if = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentencias_elseleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencias_elseright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentElse sentencias_else = (SentElse)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
					
					if(!condicion.esLogica()){
						manejarError(15,control_linea.getLine()); 
					}
					//EL SIGUIENTE CODIGO SOLO SERA UTILIZADO EN CASO DE QUE EN SENTENCIA EXTERNAS A ESTE IF-ELSE NO EXISTA SENTENCIA RETURN
					boolean retornoValido = (sentencias_if.existeSentenciaReturn() && (sentencias_else.existeElse() && sentencias_else.existeRetorno())); 
					SentIf sentenciaIF = new SentIf(); 
					if(retornoValido){
						sentenciaIF.marcarExistenciaRetorno(); 
					}
					//*************************CODIGO INTERMEDIO************************
					LabelFactory fabrica_etiquetas = new LabelFactory(); 
					LabelIF etiquetaFinIF = fabrica_etiquetas.create(); 
					LabelIF etiquetaElse = fabrica_etiquetas.create(); 
					TemporalIF temp_expresion = condicion.getTemporal(); 
					IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
					fabrica_intermedio.addQuadruples(condicion.getIntermediateCode()); 
					fabrica_intermedio.addQuadruple("BRF", temp_expresion, etiquetaElse); 
					fabrica_intermedio.addQuadruples(sentencias_if.getIntermediateCode()); 
					fabrica_intermedio.addQuadruple("BR",etiquetaFinIF); 
					fabrica_intermedio.addQuadruple("INL", etiquetaElse); 
					if(sentencias_else.existeElse()){
						fabrica_intermedio.addQuadruples(sentencias_else.getIntermediateCode()); 
					}else{
						fabrica_intermedio.addQuadruple("NOP");
					}
					fabrica_intermedio.addQuadruple("INLFIN", etiquetaFinIF); 
					sentenciaIF.setIntermediateCode(fabrica_intermedio.create());
					//*****************************************************************
					RESULT = sentenciaIF; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentAsign ::= variables error PUNTOYCOMA 
            {
              SentAsign RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentAsign ::= variables DOSPUNTOSIGUAL expresion 
            {
              SentAsign RESULT =null;
		int referencialeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int referenciaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Variables referencia = (Variables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expreleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expreright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expre = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					//EN EL NO TERMINAL **Variables** SE DELEGA LA RESPONSABILIDAD DE SABER SI EL SIMBOLO EXISTE
					SymbolIF simbolo_referenciado = scopeManager.searchSymbol(referencia.getIdentificador()); 
					//SE COMPRUEBA QUE EN EL LADO DERECHO DE LA SENTENCIA DE ASIGNACION SOLO SE HACE REFERENCIA A LA POSICION DE UN VECTOR O A UNA VARIABLE SIMPLE QUE NO SEA CONSTANTE
					if((simbolo_referenciado.getType() instanceof TypeSimple || (referencia.getTipoReferencia().equalsIgnoreCase("REFERENCIA_VECTOR"))) && !(simbolo_referenciado instanceof SymbolConstant)){
						
						//SE COMPRUEBA COINCIDENCIA QUE TANTO REFERENCIA DE LA DERECHA COMO EXPRESION DE LA IZQUIERDA SON DEL MISMO TIPO, EN CASO DE QUE ESTO NO OCURRA SE MANEJA UN ERROR Y TERMINA EL SEMANTICO
						if(!(expre.esLogica() && referencia.getTipo().equalsIgnoreCase("LOGICO")) && !(expre.getTipoExpresion().equalsIgnoreCase("ENTERO") && referencia.getTipo().equalsIgnoreCase("ENTERO") )){
							manejarError(27,linea.getLine());
						}		 
					}else{						
						manejarError(5,linea.getLine());
					}
					//********************CODIGO INTERMEDIO***************************************************************
					SentAsign sentencia_asignacion = new SentAsign(); 
					TemporalFactoryIF factoria_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
					IntermediateCodeBuilder factoria_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
					TemporalIF temporal_expresion = expre.getTemporal(); 
					TemporalIF temporal_referencia = factoria_temporales.create(); 
					
					//Se insertan las cuadruplas del lado derecho de la sentencia de asignacion
					factoria_intermedio.addQuadruples(expre.getIntermediateCode());
					
					//UNA REFERENCIA SIMPLE PUEDE SER O CONSTANTE O VARIABLE, EL ANALISIS SEMANTICO IMPIDE QUE EN ESTE PUNTO SE TRATE DE UNA CONSTANTE
					if(referencia.getTipoReferencia().equalsIgnoreCase("REFERENCIA_SIMPLE")){
						Variable var = new Variable(referencia.getIdentificador(), scopeManager.searchSymbol(referencia.getIdentificador()).getScope()); 
						factoria_intermedio.addQuadruple("MVA", temporal_referencia, var); 
						factoria_intermedio.addQuadruple("STP", temporal_referencia, temporal_expresion); 
						sentencia_asignacion.setIntermediateCode(factoria_intermedio.create());
					}else if(referencia.getTipoReferencia().equalsIgnoreCase("REFERENCIA_VECTOR")){
						factoria_intermedio.addQuadruples(referencia.getIntermediateCode()); 
						TemporalIF temp_direccionIndicadaVector = referencia.getTemporal(); 
						factoria_intermedio.addQuadruple("STP", temp_direccionIndicadaVector, temporal_expresion); 
						sentencia_asignacion.setIntermediateCode(factoria_intermedio.create()); 
					}
					//***************************************************************************************************
					RESULT = sentencia_asignacion; 
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentReturn ::= RETURN error PUNTOYCOMA 
            {
              SentReturn RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentReturn ::= RETURN expresion 
            {
              SentReturn RESULT =null;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expresion_retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expresion_retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expresion_retorno = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				
					if(expresion_retorno.getTipoExpresion().equalsIgnoreCase("ENTERO") || expresion_retorno.getTipoExpresion().equalsIgnoreCase("LOGICO")){
						SentReturn sentencia_return = new SentReturn(); 
						sentencia_return.setTipoRetorno(expresion_retorno.getTipoExpresion()); //CONTINUAR AQUI
						RESULT = sentencia_return; 
					}else{
						manejarError(20,control_linea.getLine());
					}
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentencia ::= sentProcedure 
            {
              Sentencia RESULT =null;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_PROCEDIMIENTO"); 
					RESULT = instruccion; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentencia ::= sWriteLn 
            {
              Sentencia RESULT =null;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_SALTO_LINEA"); 
					IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
					fabrica_intermedio.addQuadruple("WRITELN"); 
					instruccion.setIntermediateCode(fabrica_intermedio.create()); 
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentencia ::= sWriteInt 
            {
              Sentencia RESULT =null;
		int impresion_enteroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int impresion_enteroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SWriteInt impresion_entero = (SWriteInt)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_WRITE_ENTERO"); 
					instruccion.setIntermediateCode(impresion_entero.getIntermediateCode()); 
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentencia ::= sWriteString 
            {
              Sentencia RESULT =null;
		int impresion_textoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int impresion_textoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SWriteString impresion_texto = (SWriteString)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_WRITE_STRING"); 
					instruccion.setIntermediateCode(impresion_texto.getIntermediateCode()); 
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia ::= sentReturn 
            {
              Sentencia RESULT =null;
		int retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentReturn retorno = (SentReturn)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_RETURN"); 
					instruccion.setIntermediateCode(retorno.getIntermediateCode()); 
					instruccion.setTipoRetorno(retorno.getTipoRetorno()); 
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentencia ::= sentFor 
            {
              Sentencia RESULT =null;
		int sentencia_forleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencia_forright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentFor sentencia_for = (SentFor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_FOR"); 
					instruccion.setIntermediateCode(sentencia_for.getIntermediateCode()); 
					RESULT = instruccion; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentencia ::= sentIf 
            {
              Sentencia RESULT =null;
		int sentencia_ifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencia_ifright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentIf sentencia_if = (SentIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_IF"); 
					instruccion.setIntermediateCode(sentencia_if.getIntermediateCode()); 
					if(sentencia_if.contieneRetorno()){
						instruccion.marcarRetornoInterno(); 
					}
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia ::= sentAsign 
            {
              Sentencia RESULT =null;
		int asignacionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int asignacionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentAsign asignacion = (SentAsign)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					Sentencia instruccion = new Sentencia("SENTENCIA_ASIGNACION"); 
					instruccion.setIntermediateCode(asignacion.getIntermediateCode()); 
					RESULT = instruccion; 
				
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // listSentencia ::= sentencia 
            {
              ListSentencia RESULT =null;
		int instruccionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int instruccionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia instruccion = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	ListSentencia sentencia_simple = new ListSentencia(instruccion); 
                	//************************************************************************
                	sentencia_simple.setIntermediateCode(instruccion.getIntermediateCode()); 	
                	//************************************************************************
                	RESULT = sentencia_simple; 
         
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listSentencia",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // listSentencia ::= listSentencia PUNTOYCOMA sentencia 
            {
              ListSentencia RESULT =null;
		int listado_instruccionesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listado_instruccionesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListSentencia listado_instrucciones = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int instruccionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int instruccionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia instruccion = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	listado_instrucciones.insertarNuevaSentencia(instruccion);	
                	//****************************************************************************
                	IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
                	fabrica_intermedio.addQuadruples(listado_instrucciones.getIntermediateCode()); 
                	fabrica_intermedio.addQuadruples(instruccion.getIntermediateCode()); 
                	listado_instrucciones.setIntermediateCode(fabrica_intermedio.create()); 
                	//**************************************************************************
                	//CONTINAR AQUI PROPAGAR LINEA
          			RESULT = listado_instrucciones; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listSentencia",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencias ::= 
            {
              Sentencias RESULT =null;
		
              		Sentencias bloque_sentencias = new Sentencias(); 
              		bloque_sentencias.noExistenSentencias(); 
              		RESULT = bloque_sentencias; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // sentencias ::= listSentencia 
            {
              Sentencias RESULT =null;
		int listado_sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listado_sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListSentencia listado_sentencias = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
     
              		Sentencias bloque = manejarSentencias(listado_sentencias, -1);
              		//*******************************************************************
		  	 		bloque.setIntermediateCode(listado_sentencias.getIntermediateCode()); 
  			  	 	//******************************************************************* 
              		RESULT =  bloque; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentencias ::= listSentencia PUNTOYCOMA 
            {
              Sentencias RESULT =null;
		int listado_sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listado_sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListSentencia listado_sentencias = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		     		  
              		
              		Sentencias bloque = manejarSentencias(listado_sentencias, linea.getLine());
              	    //*******************************************************************
		  	 		bloque.setIntermediateCode(listado_sentencias.getIntermediateCode()); 
  			  	 	//******************************************************************* 
              		RESULT =  bloque; 
                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // exprLogica ::= vBooleano 
            {
              ExprLogica RESULT =null;
		int valor_logicoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_logicoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VBooleano valor_logico = (VBooleano)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	//**************************CODIGO INTERMEDIO****************
                	int valor_logico_numerico = (valor_logico.obtenerValorLogico().equalsIgnoreCase("True")) ? 1: 0; //Se asigna valor 1 o 0 dependiendo 
                	Value valor = new Value(valor_logico_numerico); 
                	TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
                	IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
                	TemporalIF temporal_logico = fabrica_temporales.create(); 
                	fabrica_intermedio.addQuadruple("MV",temporal_logico, valor); 
                	ExprLogica expr_logic = new ExprLogica(); 
                	expr_logic.setTemporal(temporal_logico); 
                	expr_logic.setIntermediateCode(fabrica_intermedio.create()); 
                	RESULT =  expr_logic; 
                	//**********************************************
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // exprLogica ::= NOT expresion 
            {
              ExprLogica RESULT =null;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion expresion = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	if(!expresion.esLogica()){
                		manejarError(26,control_linea.getLine()); 
                	}
                	//****************CODIGO INTERMEDIO******************************
                	TemporalFactory fabrica_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
                	IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
                	TemporalIF temporal_expresion = expresion.getTemporal();  
                	TemporalIF temporal_resultadoNOT = fabrica_temporales.create(); 
                	fabrica_intermedio.addQuadruples(expresion.getIntermediateCode()); 
                	fabrica_intermedio.addQuadruple("NOT",temporal_resultadoNOT, temporal_expresion); 
                	ExprLogica expr_logic = new ExprLogica(); 
                	expr_logic.setTemporal(temporal_resultadoNOT); 
                	expr_logic.setIntermediateCode(fabrica_intermedio.create()); 
                	RESULT = expr_logic; 
                	//***************************************************************
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // exprLogica ::= expresion OR expresion 
            {
              ExprLogica RESULT =null;
		int exp_izquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp_izquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp_izquierda = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp_derechaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_derecharight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp_derecha = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	if(!exp_izquierda.esLogica() || !exp_derecha.esLogica()){
                		manejarError(26,control_linea.getLine()); 
					}
					//*******************************CODIGO INTERMEDIO*************************************
                	ExprLogica expr_logic = new ExprLogica(); 
                	gestionarOperacionBinariaCI(scopeManager.getCurrentScope(), exp_izquierda, exp_derecha, "OR", null, expr_logic ); 
        			RESULT = expr_logic; 
                	//*************************************************************************************
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // exprLogica ::= expresion IGUAL expresion 
            {
              ExprLogica RESULT =null;
		int exp_izquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp_izquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp_izquierda = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp_derechaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_derecharight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp_derecha = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	if(!exp_izquierda.getTipoExpresion().equalsIgnoreCase(exp_derecha.getTipoExpresion())){
                		manejarError(26,control_linea.getLine());
                	} 
                	//*******************************CODIGO INTERMEDIO*************************************
                	ExprLogica expr_logic = new ExprLogica(); 
                	gestionarOperacionBinariaCI(scopeManager.getCurrentScope(), exp_izquierda, exp_derecha, "IGUAL", null, expr_logic ); 
        			RESULT = expr_logic; 
                	//*************************************************************************************
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // exprLogica ::= expresion MAYOR expresion 
            {
              ExprLogica RESULT =null;
		int exp_izquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp_izquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp_izquierda = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp_derechaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_derecharight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp_derecha = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					if(exp_izquierda.esLogica() || exp_derecha.esLogica()){
						manejarError(19,control_linea.getLine()); 
					}
					ExprLogica expr_logic = new ExprLogica(); 
					//**********************************CODIGO INTERMEDIO********************************************
                    gestionarOperacionBinariaCI(scopeManager.getCurrentScope(), exp_izquierda, exp_derecha, "MAYOR", null, expr_logic ); 
                    //***********************************************************************************************
                    RESULT = expr_logic; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // exprArit ::= ENTERO 
            {
              ExprArit RESULT =null;
		int numero_simpleleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numero_simpleright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token numero_simple = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                		ExprArit valor_entero_simple = new ExprArit(numero_simple.getLexema()); //es necesario propagar valor para controlar limites de vector no excedan limites
                		IntermediateCodeBuilder factoria_intermedio = new IntermediateCodeBuilder(scopeManager.getCurrentScope()); 
                		TemporalFactory factoria_temporales = new TemporalFactory(scopeManager.getCurrentScope()); 
                		TemporalIF temporal_numero = factoria_temporales.create(); 
                		Value valor_numero = new Value(Integer.parseInt(numero_simple.getLexema()));
                		factoria_intermedio.addQuadruple("MV",temporal_numero, valor_numero );  
                		valor_entero_simple.setTemporal(temporal_numero); 
                		valor_entero_simple.setIntermediateCode(factoria_intermedio.create()); 
                		RESULT = valor_entero_simple; 
                	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // exprArit ::= expresion PRODUCTO expresion 
            {
              ExprArit RESULT =null;
		int exp_izquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp_izquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp_izquierda = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp_derechaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_derecharight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp_derecha = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                      	if(!exp_izquierda.getTipoExpresion().equalsIgnoreCase("ENTERO") && !exp_derecha.getTipoExpresion().equalsIgnoreCase("ENTERO")){
                      		manejarError(26,control_linea.getLine()); 
                      	}   
                      	ExprArit expre_arit = new ExprArit(); 
                      	//**********************************CODIGO INTERMEDIO********************************************
                      	gestionarOperacionBinariaCI(scopeManager.getCurrentScope(), exp_izquierda, exp_derecha, "MULTIPLICAR", expre_arit, null ); 
                      	//***********************************************************************************************
                      	RESULT  = expre_arit;  
                      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // exprArit ::= expresion MINUS expresion 
            {
              ExprArit RESULT =null;
		int exp_izquierdaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp_izquierdaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp_izquierda = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp_derechaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_derecharight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp_derecha = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                      	if(!exp_izquierda.getTipoExpresion().equalsIgnoreCase("ENTERO") && !exp_derecha.getTipoExpresion().equalsIgnoreCase("ENTERO")){
                      		manejarError(26,control_linea.getLine()); 
                      	} 
                    	ExprArit expre_arit = new ExprArit(); 
                      	//******************************CODIGO INTERMEDIO************************************************
                      	gestionarOperacionBinariaCI(scopeManager.getCurrentScope(), exp_izquierda, exp_derecha, "RESTAR", expre_arit, null );  
                      	//************************************************************************************************
                      	RESULT  = expre_arit;                 
                      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // expresion ::= variables 
            {
              Expresion RESULT =null;
		int expresion_variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expresion_variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Variables expresion_variable = (Variables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	String id_var = expresion_variable.getIdentificador();
                	Expresion nueva_expresion = new Expresion(); 
                	//TANTO SI LA VARIABLE ES DE TIPO REFERENCIA SIMPLE, COMO DE VECTOR O FUNCION, EN ULTIMA INSTANCIA SERA, O UN ENTERO, O UN LOGICO Y DEPENDIENDO DE ESE VALOR LA EXPRESION SERA LOGICA O NO
                    if(expresion_variable.getTipo().equalsIgnoreCase("LOGICO")){
                    	nueva_expresion.setEsLogica(true); 
                    }else{
                    	nueva_expresion.setEsLogica(false); 
                    	//EN CASO DE NO SER LOGICA PUEDE SER REFERENCIA A VECTOR O A UN NUMERO ENTERO
                    	nueva_expresion.setTipoExpresion(expresion_variable.getTipo());
                    }    
                    //EL ACCESO A POSICION DE VECTOR CON UNA EXPRESION CONSTANTE DEBE SER CONTROLADO EN EL SEMANTICO EN CUANTO A QUE NO EXCEDA LIMITE
                    if(expresion_variable.esReferenciaConstante()){
                    	nueva_expresion.setEsExpresionConstante(true); 
                    	nueva_expresion.setValorExpresionConstante(expresion_variable.getValorReferenciaConstante()); 
                    }
                    //***************************************CODIGO INTERMEDIO***************************************************
                    ScopeIF ambito_actual = scopeManager.getCurrentScope(); 
                    TemporalFactory creador_temporales = new TemporalFactory(ambito_actual); 
                    IntermediateCodeBuilder factoria_intermedio = new IntermediateCodeBuilder(ambito_actual); 
                    TemporalIF temp_resultadoExpresion = creador_temporales.create(); 
                    if(expresion_variable.esReferenciaConstante()){
                    	Value valor_cte; 
                    	if(expresion_variable.esConstanteNumerica()){
                    		valor_cte = new Value(Integer.parseInt(expresion_variable.getValorReferenciaConstante())); 
                    	}else{
                    		int valor_booleano_numerico = (expresion_variable.getValorReferenciaConstante().equalsIgnoreCase("true"))? 1:0; 
                    		valor_cte = new Value(valor_booleano_numerico); 
                    	}
                    	factoria_intermedio.addQuadruple("MV", temp_resultadoExpresion, valor_cte);
                  
                    //EN CASO DE QUE NO SEA CONSTANTE SI ES UNA REFERENCIA SIMPLE SOLO QUEDA QUE SEA UNA VARIABLE
                    }else if(expresion_variable.getTipoReferencia().equalsIgnoreCase("REFERENCIA_SIMPLE") ){
                    	SymbolVariable simbolo_variable = (SymbolVariable)scopeManager.searchSymbol(expresion_variable.getIdentificador()); 
                    	Variable var = new Variable(expresion_variable.getIdentificador(), simbolo_variable.getScope()); 
                    	TemporalIF direccionVariable = creador_temporales.create(); 
                    	factoria_intermedio.addQuadruple("MVA", direccionVariable, var); 
                    	factoria_intermedio.addQuadruple("MVP",temp_resultadoExpresion, direccionVariable); 
                    }else if(expresion_variable.getTipoReferencia().equalsIgnoreCase("REFERENCIA_VECTOR")){
                    	
                    	nueva_expresion.marcarComoReferenciaAVector(); 
                    	TemporalIF direccionVector = expresion_variable.getTemporal(); 
                       	factoria_intermedio.addQuadruples(expresion_variable.getIntermediateCode()); 
                       	factoria_intermedio.addQuadruple("MVP", temp_resultadoExpresion,direccionVector); 
                    }
					nueva_expresion.setTemporal(temp_resultadoExpresion); 
					nueva_expresion.setIntermediateCode(factoria_intermedio.create());
                    //*******************************************************************************************************************     	
                	RESULT = nueva_expresion; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // expresion ::= PARENIZQ expresion PARENDER 
            {
              Expresion RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                    RESULT = exp; //se devuelve la expresion contenida dentro de la expresion
                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // expresion ::= exprLogica 
            {
              Expresion RESULT =null;
		int exp_logicleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_logicright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExprLogica exp_logic = (ExprLogica)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                 	Expresion expresion_logica = new Expresion();
                 	expresion_logica.setEsLogica(true); 
                 	expresion_logica.setIntermediateCode(exp_logic.getIntermediateCode()); 
                 	expresion_logica.setTemporal(exp_logic.getTemporal()); 
                 	RESULT = expresion_logica;
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expresion ::= exprArit 
            {
              Expresion RESULT =null;
		int exp_aritleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp_aritright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExprArit exp_arit = (ExprArit)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
					Expresion expresion_aritmetica = new Expresion();
					expresion_aritmetica.setEsLogica(false); 
					expresion_aritmetica.setTipoExpresion("ENTERO"); 
					//PARA CONTROLAR ACCESO A VECTORES CON NUMEROS
					if(exp_arit.esUnNumeroSimple()){
						expresion_aritmetica.setValorNumericoSimple(exp_arit.getValorNumericoSimple()); 
					}
					
					//*******************CODIGO INTERMEDIO**********************************
					expresion_aritmetica.setIntermediateCode(exp_arit.getIntermediateCode()); 
					expresion_aritmetica.setTemporal(exp_arit.getTemporal()); 
					//***********************************************************
					RESULT = expresion_aritmetica;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // tipoRetorno ::= DOSPUNTOS error PUNTOYCOMA 
            {
              TipoRetorno RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // tipoRetorno ::= 
            {
              TipoRetorno RESULT =null;
		
                		TipoRetorno tipo_retorno = new TipoRetorno("NO_RETORNO"); 
						RESULT = tipo_retorno;                  	
                	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // tipoRetorno ::= DOSPUNTOS intOBool 
            {
              TipoRetorno RESULT =null;
		int primitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int primitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IntOBool primitivo = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						TipoRetorno tipo_retorno = new TipoRetorno(primitivo.getTipo()); 
						RESULT = tipo_retorno;  
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // procParam ::= cadIdVar error PUNTOYCOMA 
            {
              ProcParam RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParam",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // procParam ::= cadIdVar DOSPUNTOS tipoVar 
            {
              ProcParam RESULT =null;
		int cadena_idsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cadena_idsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CadIdVar cadena_ids = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TipoVar tipo = (TipoVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					//se comprueba que los tipos declarados como parametros de subprograma son legitimos y han sido declarados previamente
					if(tipo.getTipoVar().equalsIgnoreCase("LOGICO") || tipo.getTipoVar().equalsIgnoreCase("ENTERO")){
						ScopeIF ambito_actual = scopeManager.getCurrentScope(); 
						SymbolTableIF tabla_simbolos = ambito_actual.getSymbolTable(); 
						ArrayList<String> listado_ids = cadena_ids.getListadoIdentificadores(); 
						TypeIF tipo_asociado = scopeManager.searchType(tipo.getTipoVar()); 
						ProcParam param_agrupados_tipo = new ProcParam();  
						param_agrupados_tipo.setNombreTipo(tipo.getTipoVar());
						for(int i = 0; i < listado_ids.size(); i++){
							
							//SE COMPRUEBA SI SE HAN INSERTADOS DOS VARIABLES IGUALES EN CABECERA DE PROCEDIMIENTO O FUNCION
							if(tabla_simbolos.containsSymbol(listado_ids.get(i))){
								manejarError(11,control_linea.getLine()); 
							}else{
								SymbolIF variable_nueva = new SymbolVariable(ambito_actual, listado_ids.get(i), tipo_asociado); 
							    tabla_simbolos.addSymbol(listado_ids.get(i), variable_nueva); 
							    param_agrupados_tipo.incrementarNumParametros(); 			
							} 
						}
						//PROPAGACION HACIA ARRIBA DEL ATRIBUTO (NUMERO DE ATRIBUTOS Y TIPO DE DE UN GRUPO DE ATRIBUTOS) 
						RESULT = param_agrupados_tipo; 
					}else{
						manejarError(12,control_linea.getLine());
					}			
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParam",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // procListParam ::= 
            {
              ProcListParam RESULT =null;
			
                    ProcListParam vacio = new ProcListParam(); //un constructor de **ProcListParam()** sin para parametros indica que no hay parametros formales
                	RESULT = vacio; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // procListParam ::= procParam 
            {
              ProcListParam RESULT =null;
		int grupo_parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int grupo_parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ProcParam grupo_parametros = (ProcParam)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	    String tipo = grupo_parametros.getNombreTipo(); 
                		ProcListParam grupo_param = new ProcListParam(tipo);
                		
                		//EL BUCLE EMPIEZA EN UNO PORQUE YA SE HA INSERTADO EL PRIMER TIPO PREVIAMENTE
                		for(int i = 1; i < grupo_parametros.getNumParametros(); i++){
                			grupo_param.insertarParametroFormal(tipo);
                		}
                		RESULT = grupo_param; 
                	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // procListParam ::= procParam PUNTOYCOMA procListParam 
            {
              ProcListParam RESULT =null;
		int nuevo_grupoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nuevo_gruporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ProcParam nuevo_grupo = (ProcParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int grupo_anteriorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int grupo_anteriorright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ProcListParam grupo_anterior = (ProcListParam)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					ProcListParam grupo_parametros; 
					if(grupo_anterior.esVacio()){
                		grupo_parametros = new ProcListParam();              
					}else{
						grupo_parametros = grupo_anterior;  
					}
					
					for(int i = 0; i < nuevo_grupo.getNumParametros(); i++){
						grupo_parametros.insertarParametroFormal(nuevo_grupo.getNombreTipo()); 	
					}
					RESULT = grupo_parametros; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // procParenParam ::= 
            {
              ProcParenParam RESULT =null;
		
                	ProcParenParam param_entrada = new ProcParenParam(); 
                	param_entrada.setExistenParametros(false); 
                	RESULT = param_entrada; 
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParenParam",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // procParenParam ::= PARENIZQ procListParam PARENDER 
            {
              ProcParenParam RESULT =null;
		int listado_parametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listado_parametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcListParam listado_parametros = (ProcListParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                	ProcParenParam param_entrada = new ProcParenParam();               	
                	param_entrada.setExistenParametros(listado_parametros.esVacio()); 
                	param_entrada.insertarTodosParametros(listado_parametros.getListaParametrosFormales());  	
                	RESULT = param_entrada;
                
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParenParam",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // cabProcedure ::= PROCEDURE error 
            {
              CabProcedure RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // cabProcedure ::= PROCEDURE IDENTIFICADOR error 
            {
              CabProcedure RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // cabProcedure ::= PROCEDURE IDENTIFICADOR NT$3 procParenParam tipoRetorno PUNTOYCOMA 
            {
              CabProcedure RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (CabProcedure) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int id_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int id_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id_proceso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int param_formarlesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int param_formarlesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ProcParenParam param_formarles = (ProcParenParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int retornoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int retornoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TipoRetorno retorno = (TipoRetorno)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
 						
						String nombre_proceso = id_proceso.getLexema(); 
						CabProcedure cabecera_proceso = new CabProcedure(nombre_proceso);			 
						ScopeIF ambito_actual = scopeManager.getCurrentScope();
						
						//COMPROBACION DE SI ES FUNCION O DE SI ES PROCEDIMIENTO
						TypeIF subProgram; 
						SymbolIF subProgramSimbolo; 
						
						ScopeIF ambito_nivel_superior = scopeManager.getParentScope(); 
						SymbolTableIF tabla_simbolos_ambito_superior = ambito_nivel_superior.getSymbolTable(); 
						TypeTableIF tabla_tipos_ambito_superior = ambito_nivel_superior.getTypeTable(); 
						
						ArrayList<String> tipos_formales = param_formarles.getTiposFormarles(); 
						
						// SI NO SE PUEDE HACER FUNCIONES CON EQUIVALENCIA NOMINAL A OTRAS FUNCIONES DE TODOS LOS AMBITOS ;LO MISMO CON LOS TIPOS
						if(scopeManager.containsType(nombre_proceso) || scopeManager.containsSymbol(nombre_proceso)){
							manejarError(13,id_proceso.getLine()); 
						}else{
							if(retorno.existeRetorno()){  // si existe retorno se crea un tipo fuction en caso negativo se crea un tipo procedure
								cabecera_proceso.setTipoRetorno(retorno.getTipoRetorno()); 
								cabecera_proceso.setTipoSubProgram("FUNCION"); 	
								subProgram = new TypeFunction(ambito_nivel_superior,nombre_proceso, retorno.getTipoRetorno(), tipos_formales);
								subProgramSimbolo = new SymbolFunction(ambito_nivel_superior, nombre_proceso, subProgram,retorno.getTipoRetorno(), tipos_formales); 
							}else{
								cabecera_proceso.setTipoSubProgram("PROCEDIMIENTO"); 
								subProgram = new TypeProcedure(ambito_nivel_superior, nombre_proceso, tipos_formales); 
								subProgramSimbolo = new SymbolProcedure(ambito_nivel_superior, nombre_proceso, subProgram, tipos_formales);
							}
							
							if(param_formarles.existenParametrosEntrada()){
							    //al existir parametros de entrada se deben insertar estos en la tabla de simbolos del procedimiento
								SymbolTableIF tabla_simbolos = ambito_actual.getSymbolTable(); 
							}
							tabla_tipos_ambito_superior.addType(subProgram);						
							tabla_simbolos_ambito_superior.addSymbol(subProgramSimbolo); 
							RESULT = cabecera_proceso; 
						}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$3 ::= 
            {
              CabProcedure RESULT =null;
		int id_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id_proceso = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

						scopeManager.openScope(id_proceso.getLexema());
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // stmSubprogram ::= 
            {
              StmSubprogram RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmSubprogram",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // stmSubprogram ::= cabProcedure cuerpo NT$2 stmSubprogram 
            {
              StmSubprogram RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (StmSubprogram) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cabecera_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cabecera_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		CabProcedure cabecera_proceso = (CabProcedure)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cuerpo_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cuerpo_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Cuerpo cuerpo_proceso = (Cuerpo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmSubprogram",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$2 ::= 
            {
              StmSubprogram RESULT =null;
		int cabecera_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cabecera_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CabProcedure cabecera_proceso = (CabProcedure)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cuerpo_procesoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerpo_procesoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Cuerpo cuerpo_proceso = (Cuerpo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                   		//COMPROBACION DE EXISTENCIA DE LA SENTENCIA RETURN
                   		if(cabecera_proceso.getTipoSubprogram().equalsIgnoreCase("FUNCION")){
                   			if(cuerpo_proceso.existeReturn()){
                   				if(cabecera_proceso.getTipoRetorno().equalsIgnoreCase(cuerpo_proceso.getTipoRetorno())){	
                   				}else{
                   					manejarError(22, cuerpo_proceso.getNumLineaIdFin()); 
                   				}
                   			}else{	
                   				manejarError(14, cuerpo_proceso.getNumLineaIdFin());
                   			}			 
                   		}
                   		//COMPROBACION DE CONCORDANCIA ENTRE IDENTIFICADOR DE CABECERA DE PROCESO E IDENTIFICADOR DE FINAL DE PROCESO
                   		if(cuerpo_proceso.getIdentificadorFinal().equalsIgnoreCase(cabecera_proceso.getNombreProceso())){
                   			scopeManager.closeScope();
                   		}else{
                   			manejarError(3,cuerpo_proceso.getNumLineaIdFin()); 
                   		}	
                  	    
                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // tipoVar ::= IDENTIFICADOR 
            {
              TipoVar RESULT =null;
		int id_tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id_tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id_tipo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                		TipoVar tipo_variable = new TipoVar(id_tipo.getLexema()); 
                		RESULT = tipo_variable; 
                	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoVar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tipoVar ::= intOBool 
            {
              TipoVar RESULT =null;
		int tipo_primitivoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tipo_primitivoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IntOBool tipo_primitivo = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						TipoVar tipo_variable = new TipoVar(tipo_primitivo.getTipo()); 
						RESULT = tipo_variable; 
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoVar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // cadIdVar ::= IDENTIFICADOR 
            {
              CadIdVar RESULT =null;
		int id_variableleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id_variableright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id_variable = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                		//CUANDO SE CONSTUYE UN OBJETO DE TIPO **CadIdVar** SE ENVIA COMO PARAMETRO EL PRIMER PARAMETRO
                	    CadIdVar  identificador = new CadIdVar(id_variable.getLexema()); 
                	    RESULT = identificador; 
                	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cadIdVar",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // cadIdVar ::= IDENTIFICADOR COMA cadIdVar 
            {
              CadIdVar RESULT =null;
		int id_varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id_varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id_var = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cadena_identificadoresleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cadena_identificadoresright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CadIdVar cadena_identificadores = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					cadena_identificadores.insertarNuevoIdentificador(id_var.getLexema());
					RESULT = cadena_identificadores; 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cadIdVar",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // expVar ::= cadIdVar error PUNTOYCOMA 
            {
              ExpVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expVar",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // expVar ::= cadIdVar DOSPUNTOS tipoVar PUNTOYCOMA 
            {
              ExpVar RESULT =null;
		int cadena_variablesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cadena_variablesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		CadIdVar cadena_variables = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int info_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int info_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token info_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipo_varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipo_varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TipoVar tipo_var = (TipoVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                 	ScopeIF ambito_actual = scopeManager.getCurrentScope(); 
                 	TypeTableIF tabla_tipos = ambito_actual.getTypeTable(); 
                 	SymbolTableIF tabla_simbolos = ambito_actual.getSymbolTable(); 
					if(scopeManager.containsType(tipo_var.getTipoVar())){           //se comprueba que existe el tipo de variable utilizado (boolean, integer o vectores personalizados)
						ArrayList<String> listado_identificadores = cadena_variables.getListadoIdentificadores(); 
						for(int i = 0; i < listado_identificadores.size(); i++){
							if(tabla_simbolos.containsSymbol(listado_identificadores.get(i))){ //si el simbolo declarado existe se lanza error por duplicacion de nombres
								manejarError(13,info_linea.getLine()); 
							}else{
								SymbolVariable nueva_variable = new SymbolVariable(ambito_actual, listado_identificadores.get(i), scopeManager.searchType(tipo_var.getTipoVar())); 
								tabla_simbolos.addSymbol(nueva_variable); 
							}
						}
					}else{
						manejarError(29,info_linea.getLine()); 
					}
                 
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expVar",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // sentVar ::= expVar 
            {
              SentVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentVar",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // sentVar ::= sentVar expVar 
            {
              SentVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentVar",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // stmVar ::= VAR error 
            {
              StmVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // stmVar ::= 
            {
              StmVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // stmVar ::= VAR sentVar 
            {
              StmVar RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // expTipo ::= IDENTIFICADOR error PUNTOYCOMA 
            {
              ExpTipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expTipo",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // expTipo ::= IDENTIFICADOR IGUAL ARRAY CORCHIZQ entOid PUNTOPUNTO entOid CORCHDER OF intOBool PUNTOYCOMA 
            {
              ExpTipo RESULT =null;
		int id_tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int id_tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		Token id_tipo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int limite_infleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int limite_infright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		EntOid limite_inf = (EntOid)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int limite_supleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int limite_supright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		EntOid limite_sup = (EntOid)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipo_vectorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tipo_vectorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		IntOBool tipo_vector = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   
	ScopeIF ambito_actual = scopeManager.getCurrentScope();            
	TypeTableIF tabla_tipos = ambito_actual.getTypeTable(); 
	SymbolTableIF tabla_simbolos = ambito_actual.getSymbolTable(); 
	if(scopeManager.containsType(id_tipo.getLexema())){
		manejarError(4, id_tipo.getLine()); 
	}else{
		TypeArray nuevo_vector = new TypeArray(ambito_actual, id_tipo.getLexema(), tipo_vector.getTipo()); 
		String limite_inferior = tratarLimite(limite_inf, id_tipo.getLine()); 
		String limite_superior = tratarLimite(limite_sup, id_tipo.getLine()); 
		nuevo_vector.setLimiteInferior(limite_inferior);
		nuevo_vector.setLimiteSuperior(limite_superior); 
   	    if(nuevo_vector.getLongitud() > 0){ // Se comprueba que la longitud del vector es legitima
   	    	tabla_tipos.addType(nuevo_vector); 
   	    }else{
   	   		manejarError(18, id_tipo.getLine()); 
   	    } 
	}
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expTipo",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // sentTipo ::= expTipo 
            {
              SentTipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentTipo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // sentTipo ::= sentTipo expTipo 
            {
              SentTipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentTipo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // stmTipos ::= TYPE error 
            {
              StmTipos RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // stmTipos ::= 
            {
              StmTipos RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // stmTipos ::= TYPE sentTipo 
            {
              StmTipos RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // valorConst ::= vBooleano 
            {
              ValorConst RESULT =null;
		int valor_logicoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valor_logicoright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VBooleano valor_logico = (VBooleano)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                	//para aumentar legibilidad de codigo se instancian de manera explicita el tipo de constante y su valor literal asociado
                	String tipo_cte = "LOGICO";
                	String valor = valor_logico.obtenerValorLogico();
                	
                	// Se instancia un objeto de la clase ValorConst cuyo fin es propagar hacia arriba tipo de cte y el valor declarado
                	ValorConst cte_logica = new ValorConst(tipo_cte,valor);    
                	RESULT = cte_logica;          
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorConst",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // valorConst ::= ENTERO 
            {
              ValorConst RESULT =null;
		int enteroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int enteroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token entero = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					    //para aumentar legibilidad de codigo se instancian de manera explicita el tipo de constante y su valor literal asociado
					   	String tipo_cte = "ENTERO"; 
					   	String valor = entero.getLexema(); 
					   	
					   	// Se instancia un objeto de la clase ValorConst cuyo fin es propagar hacia arriba tipo de cte y el valor declarado
						ValorConst cte_entera = new ValorConst(tipo_cte, valor);
						RESULT = cte_entera; 
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorConst",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // expConst ::= IDENTIFICADOR error PUNTOYCOMA 
            {
              ExpConst RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expConst",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // expConst ::= IDENTIFICADOR IGUAL valorConst PUNTOYCOMA 
            {
              ExpConst RESULT =null;
		int id_cteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int id_cteright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id_cte = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valor_cteleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valor_cteright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ValorConst valor_cte = (ValorConst)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                    	//Se instancia el ambito actual y su tabla de simbolos asociada para aumentar la legibilidad del codigo
                    	ScopeIF ambito_actual = scopeManager.getCurrentScope();     	
                    	SymbolTableIF tabla_simbolos = ambito_actual.getSymbolTable(); 
                    	
                    	
                    	if(tabla_simbolos.containsSymbol(id_cte.getLexema())){          //Se comprueba si la cte ha sido previamente declarada en el mismo ambito. 
                    		manejarError(13,id_cte.getLine());                          //En caso afirmativo se informa de error
                    	}else{                                                          //En caso negativo se inicia el procedimiento para crear un simbolo constante
	                    	String tipo_cte = valor_cte.getTipoConstante(); 
	                    	String valor = valor_cte.getValorConstante();               //se instancia tipo_cte y valor para aumentar legibilidad de codigo
	                    	
	                    	//El tipo de constante tiene que estar en la tabla de simbolos, cabiendo indicar que tipo_cte solo puede tener valor LOGICO o ENTERO
	                    	TypeIF tipo_dato = scopeManager.searchType(tipo_cte);; 
	                    	SymbolConstant nueva_cte = new SymbolConstant(ambito_actual, id_cte.getLexema(), tipo_dato ,valor); //Se crear un objeto de tipo simbolo y se inserta en la tabla de simbolos del ambito actual      
	                    	tabla_simbolos.addSymbol(nueva_cte);  
	                    }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expConst",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // sentConst ::= expConst 
            {
              SentConst RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentConst",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // sentConst ::= sentConst expConst 
            {
              SentConst RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentConst",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // stmConstantes ::= CONST error 
            {
              StmConstantes RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // stmConstantes ::= 
            {
              StmConstantes RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // stmConstantes ::= CONST sentConst 
            {
              StmConstantes RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN error 
            {
              Cuerpo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN sentencias END error 
            {
              Cuerpo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN sentencias END IDENTIFICADOR PUNTOYCOMA 
            {
              Cuerpo RESULT =null;
		int lista_sentenciasleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int lista_sentenciasright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencias lista_sentencias = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int control_linealeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int control_linearight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token control_linea = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id_fin_cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id_fin_cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id_fin_cuerpo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                  	Cuerpo cuerpo_programa = new Cuerpo(); 
                  	cuerpo_programa.setIdentificadorFinal(id_fin_cuerpo.getLexema());
                  	cuerpo_programa.setNumLineaIdFin(id_fin_cuerpo.getLine());
                  	if(lista_sentencias.existeSentenciaReturn()){
                  		cuerpo_programa.sentenciaReturnEncontrada();
                  		cuerpo_programa.setTipoRetorno(lista_sentencias.getTipoRetorno());	
                  	}
                  	//**********************************CODIGO INTERMEDIO************************************
                  	cuerpo_programa.setIntermediateCode(lista_sentencias.getIntermediateCode()); 
                  	//***************************************************************************************
                    RESULT = cuerpo_programa; 
                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // cabModule ::= MODULE error 
            {
              CabModule RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabModule",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // cabModule ::= MODULE IDENTIFICADOR PUNTOYCOMA 
            {
              CabModule RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
                  	String nombre_programa = id.getLexema(); //Obtenemos el nombre del programa
                  	CabModule cabecera_modulo = new CabModule(); //Instanciamos un objeto de tipo cabecera de modulo
                  	cabecera_modulo.setNombreModulo(nombre_programa); //Asignamos a ese objeto de tipo cabecera de modulo un nombre  
                  	RESULT = cabecera_modulo; //Se propaga hacia arriba el objeto previamente creado con el atributo nombre_programa. 
                  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabModule",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // axiom ::= cabModule error 
            {
              Axiom RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= cabModule NT$1 cuerpo 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cabecera_moduloleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cabecera_moduloright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CabModule cabecera_modulo = (CabModule)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cuerpo_programaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerpo_programaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Cuerpo cuerpo_programa = (Cuerpo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
        	Axiom ax = new Axioma();  
	        ax.setAmbitoCentral(scopeManager.getCurrentScope()); //se propaga hacia arriba el ambito principal (es el unico que se va a traducir a codigo final)
        	//SE COMPRUEBA QUE LA ETIQUETA DESPUES DEL END COINCIDEN CON EL IDENTIFICADOR DEL PROGRAMA
        	if(cabecera_modulo.getNombreModulo().equalsIgnoreCase(cuerpo_programa.getIdentificadorFinal())){
        		scopeManager.closeScope(); //Cerramos el ambito global, (el primero creado), dado que tras compilar el cuerpo, se ha acabado el programa. 
        	}else{
        		manejarError(3, cuerpo_programa.getNumLineaIdFin()); 
        	}
        	ax.setIntermediateCode(cuerpo_programa.getIntermediateCode()); //Se propaga hacia arriba el codigo intermedio del cuerpo del programa PRINCIPAL
        	RESULT = ax; 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;
		int cabecera_moduloleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cabecera_moduloright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CabModule cabecera_modulo = (CabModule)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

        	//PARTE 1: CREACION DE AMBITO GLOBAL CON NOMBRE DE PROGRAMA
	        //Abrimos un ambito, que en este contexto se trata del ambito global del programa de nivel 0
	        
	        scopeManager.openScope(cabecera_modulo.getNombreModulo()); 
	        
	        
	        //Se instancia un objeto de tipo ambito y se le hace corresponder con el ambito actual
	        ScopeIF scope = scopeManager.getCurrentScope();
	      
			
			//PARTE 2: INSERCION EN LA TABLA DE TIPOS LOS TIPOS PRIMITIVOS INTEGER Y BOOLEAN
			//se obtiene la tabla_tipos del ambito actual
			TypeTableIF tabla_tipos = scope.getTypeTable(); 
			
			//Se instancia un tipo primitivo entero y un tipo primitivo logico
			TypeSimple tipo_entero = new TypeSimple(scope, "ENTERO");
			TypeSimple tipo_logico = new TypeSimple(scope, "LOGICO"); 
			
			//Se insertan los tipos declarados previamente en la tabla de tipos del ambito global
			tabla_tipos.addType("ENTERO", tipo_entero);
			tabla_tipos.addType("LOGICO", tipo_logico); 
	
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  		//EN ESTA PRACTICA NO SE CONTEMPLA EL TRATAMIENTO DE SUBPROGRAMAS; SOLO SE TRABAJA CON AMBITO DE PROGRAMA PRINCIPAL
  		ExecutionEnvironmentEns2001  entorno_ejecucion = new ExecutionEnvironmentEns2001 (); 
  		ScopeIF ambito_principal = ax.getAmbitoCentral(); 
  		IntermediateCodeBuilder fabrica_intermedio = new IntermediateCodeBuilder(ambito_principal); 
  		
  		int direccion_base_memoria = entorno_ejecucion.getMemorySize();                //se obtiene direccion base del entorno de ejecucion (65535)
  		List<SymbolIF> simbolos = ambito_principal.getSymbolTable().getSymbols();      //se obtiene el listado de simbolos de todo el listado principal)
  		for(SymbolIF simbolo: simbolos){                                               
  			if(simbolo instanceof SymbolVariable){
  				((SymbolVariable)simbolo).setDireccion(direccion_base_memoria); 	   //se establece la direccion estatica de cada variable (DEL AMBITO PRINCIPAL, EL RESTO ES PARTE OBLIGATORIA)
  				//System.out.println("Se procede a guardar en la direccion " + direccion_base_memoria + " la variable " +simbolo.getName()); //Descomentar esta linea si se quiere mas informacion de donde se guarda cada variable
  				Variable var = new Variable(simbolo.getName(), simbolo.getScope()); 
  				fabrica_intermedio.addQuadruple("INICIAR_DATOS_GLOBALES", var, 0);                //Se crea una quadrupla personalizada para inicializar valores de variables globales
  				direccion_base_memoria = direccion_base_memoria - simbolo.getType().getSize();    //se decrementa en una unidad la direccion estatica actual
  			}
  		} 

  		List<TemporalIF> temporales = ambito_principal.getTemporalTable().getTemporals(); //mismo procedimiento que anterior pero con temporales
  		for(TemporalIF temporal: temporales){
  			((Temporal)temporal).setAddress(direccion_base_memoria); 
  			//System.out.println("Se procede a guardar en la direccion " + direccion_base_memoria + " el temporal "+ temporal.getName()); 
  			direccion_base_memoria = direccion_base_memoria - ((Temporal)temporal).getSize(); 
  		}
  		fabrica_intermedio.addQuadruples(ax.getIntermediateCode());   //se inserta todos las quadruplas del programa principal
  		fabrica_intermedio.addQuadruple("HALT");                      // se inserta quaudrupla de fin de programa
  		for(int i = 0; i < listaStrings.size(); i++){				 //se inserta etiquetas que contiene datos de cadenas de texto para imprimir
  			fabrica_intermedio.addQuadruple(listaStrings.get(i)); 
  		}
  		 
  		ax.setIntermediateCode(fabrica_intermedio.create());        
  		//**********************************
  		//**** DESCOMENTAR LINEAS DE 437 A 439 SI SE QUIERE VER CODIGO INTERMEDIO Y SU EQUIVALENTE EN CODIGO FINAL EN CONSOLA DE ECLIPSE
  		//**********************************
  		//for(QuadrupleIF x: ax.getIntermediateCode()){
  		//	System.out.println(entorno_ejecucion.translate(x));
  		//}
  		// No modificar esta estructura, aunque se pueden insertar mas acciones semanticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
  		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no esta completo. Esto es debido a que 
  		// aun no se tendra implementada la generacion de codigo intermedio ni final.
  		// Para la entrega final deberian descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing...");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

